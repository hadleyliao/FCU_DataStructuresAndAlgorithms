<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/ArrayBinaryTreeGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ArrayBinaryTreeGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class ArrayBinaryTreeGUI extends JPanel {&#10;    String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;};&#10;    JTextField inputField;&#10;    JButton updateButton;&#10;    JButton deleteButton;&#10;    JButton randomButton;&#10;    JLabel infoLabel;&#10;    JRadioButton inorderButton;&#10;    JRadioButton preorderButton;&#10;    JRadioButton postorderButton;&#10;    JButton traverseButton;&#10;    JTextArea resultArea;&#10;&#10;    public ArrayBinaryTreeGUI() {&#10;        setLayout(new BorderLayout());&#10;        JPanel topPanel = new JPanel();&#10;        inputField = new JTextField(15); // 將欄位長度由30改為15&#10;        updateButton = new JButton(&quot;更新陣列&quot;);&#10;        deleteButton = new JButton(&quot;刪除節點&quot;);&#10;        randomButton = new JButton(&quot;隨機產生N個數字&quot;);&#10;        infoLabel = new JLabel(&quot;請輸入以逗號分隔的節點（如：A,B,C,D,E,F,G）&quot;);&#10;        topPanel.add(infoLabel);&#10;        topPanel.add(inputField);&#10;        topPanel.add(updateButton);&#10;        topPanel.add(deleteButton);&#10;        topPanel.add(randomButton);&#10;        add(topPanel, BorderLayout.NORTH);&#10;        updateButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            if (!text.isEmpty()) {&#10;                arr = text.split(&quot;,&quot;);&#10;                for (int i = 0; i &lt; arr.length; i++) {&#10;                    arr[i] = arr[i].trim();&#10;                    if (arr[i].isEmpty()) arr[i] = null;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;        deleteButton.addActionListener(e -&gt; {&#10;            String key = inputField.getText().trim();&#10;            if (key.isEmpty()) return;&#10;            // 找到所有等於 key 的節點&#10;            for (int i = 0; i &lt; arr.length; i++) {&#10;                if (arr[i] != null &amp;&amp; arr[i].equals(key)) {&#10;                    // 判斷是否為樹葉節點&#10;                    int left = 2 * i + 1;&#10;                    int right = 2 * i + 2;&#10;                    boolean isLeaf = (left &gt;= arr.length || arr[left] == null) &amp;&amp; (right &gt;= arr.length || arr[right] == null);&#10;                    if (isLeaf) {&#10;                        arr[i] = null;&#10;                    } else {&#10;                        // 只將該節點及其子樹設為 null，不重整陣列&#10;                        deleteSubtree(i);&#10;                    }&#10;                }&#10;            }&#10;            repaint();&#10;        });&#10;        randomButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            int n;&#10;            try {&#10;                n = Integer.parseInt(text);&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入有效的整數N&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;                return;&#10;            }&#10;            // 產生不重複的隨機數字&#10;            java.util.Set&lt;Integer&gt; set = new java.util.LinkedHashSet&lt;&gt;();&#10;            java.util.Random rand = new java.util.Random();&#10;            int max = Math.max(n * 2, 100);&#10;            while (set.size() &lt; n) {&#10;                set.add(rand.nextInt(max));&#10;            }&#10;            // 將現有陣列擴充或覆蓋&#10;            arr = set.stream().map(String::valueOf).toArray(String[]::new);&#10;            repaint();&#10;        });&#10;        // 拜訪選項與結果顯示&#10;        inorderButton = new JRadioButton(&quot;Inorder&quot;);&#10;        preorderButton = new JRadioButton(&quot;Preorder&quot;);&#10;        postorderButton = new JRadioButton(&quot;Postorder&quot;);&#10;        traverseButton = new JButton(&quot;拜訪&quot;);&#10;        resultArea = new JTextArea(5, 60);&#10;        resultArea.setEditable(false);&#10;        JPanel traversePanel = new JPanel();&#10;        traversePanel.add(new JLabel(&quot;選擇拜訪方式：&quot;));&#10;        traversePanel.add(inorderButton);&#10;        traversePanel.add(preorderButton);&#10;        traversePanel.add(postorderButton);&#10;        traversePanel.add(traverseButton);&#10;        // add(traversePanel, BorderLayout.CENTER); // 移除這行&#10;        // add(new JScrollPane(resultArea), BorderLayout.SOUTH); // 移除這行&#10;        // 新增一個底層面板，垂直排列樹狀圖與拜訪選項&#10;        JPanel bottomPanel = new JPanel();&#10;        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));&#10;        bottomPanel.add(traversePanel);&#10;        bottomPanel.add(new JScrollPane(resultArea));&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;        traverseButton.addActionListener(e -&gt; {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderButton.isSelected()) {&#10;                sb.append(&quot;Inorder: &quot;);&#10;                inorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (preorderButton.isSelected()) {&#10;                sb.append(&quot;Preorder: &quot;);&#10;                preorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (postorderButton.isSelected()) {&#10;                sb.append(&quot;Postorder: &quot;);&#10;                postorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (!inorderButton.isSelected() &amp;&amp; !preorderButton.isSelected() &amp;&amp; !postorderButton.isSelected()) {&#10;                sb.append(&quot;請至少選擇一種拜訪方式！\n&quot;);&#10;            }&#10;            resultArea.setText(sb.toString());&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        drawTree(g, 0, getWidth() / 2 - 15, 80, 120);&#10;    }&#10;&#10;    void drawTree(Graphics g, int index, int x, int y, int xOffset) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        g.drawOval(x, y, 30, 30);&#10;        g.drawString(arr[index], x + 12, y + 20);&#10;        int left = 2 * index + 1;&#10;        if (left &lt; arr.length &amp;&amp; arr[left] != null) {&#10;            g.drawLine(x + 15, y + 30, x - xOffset + 15, y + 80);&#10;            drawTree(g, left, x - xOffset, y + 80, xOffset / 2);&#10;        }&#10;        int right = 2 * index + 2;&#10;        if (right &lt; arr.length &amp;&amp; arr[right] != null) {&#10;            g.drawLine(x + 15, y + 30, x + xOffset + 15, y + 80);&#10;            drawTree(g, right, x + xOffset, y + 80, xOffset / 2);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除子樹&#10;    void deleteSubtree(int index) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        arr[index] = null;&#10;        deleteSubtree(2 * index + 1);&#10;        deleteSubtree(2 * index + 2);&#10;    }&#10;&#10;    // inorder 拜訪&#10;    void inorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        inorder(2 * index + 1, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        inorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // preorder 拜訪&#10;    void preorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        preorder(2 * index + 1, sb);&#10;        preorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // postorder 拜訪&#10;    void postorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        postorder(2 * index + 1, sb);&#10;        postorder(2 * index + 2, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Array Binary Tree Visualization&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(1000, 600);&#10;        frame.add(new ArrayBinaryTreeGUI());&#10;        frame.setVisible(true);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class ArrayBinaryTreeGUI extends JPanel {&#10;    String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;};&#10;    JTextField inputField;&#10;    JButton updateButton;&#10;    JButton deleteButton;&#10;    JButton randomButton;&#10;    JLabel infoLabel;&#10;    JCheckBox inorderBox;&#10;    JCheckBox preorderBox;&#10;    JCheckBox postorderBox;&#10;    JButton traverseButton;&#10;    JTextArea resultArea;&#10;&#10;    public ArrayBinaryTreeGUI() {&#10;        setLayout(new BorderLayout());&#10;        JPanel topPanel = new JPanel();&#10;        inputField = new JTextField(15); // 將欄位長度由30改為15&#10;        updateButton = new JButton(&quot;更新陣列&quot;);&#10;        deleteButton = new JButton(&quot;刪除節點&quot;);&#10;        randomButton = new JButton(&quot;隨機產生N個數字&quot;);&#10;        infoLabel = new JLabel(&quot;請輸入以逗號分隔的節點（如：A,B,C,D,E,F,G）&quot;);&#10;        topPanel.add(infoLabel);&#10;        topPanel.add(inputField);&#10;        topPanel.add(updateButton);&#10;        topPanel.add(deleteButton);&#10;        topPanel.add(randomButton);&#10;        add(topPanel, BorderLayout.NORTH);&#10;        updateButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            if (!text.isEmpty()) {&#10;                arr = text.split(&quot;,&quot;);&#10;                for (int i = 0; i &lt; arr.length; i++) {&#10;                    arr[i] = arr[i].trim();&#10;                    if (arr[i].isEmpty()) arr[i] = null;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;        deleteButton.addActionListener(e -&gt; {&#10;            String key = inputField.getText().trim();&#10;            if (key.isEmpty()) return;&#10;            // 找到所有等於 key 的節點&#10;            for (int i = 0; i &lt; arr.length; i++) {&#10;                if (arr[i] != null &amp;&amp; arr[i].equals(key)) {&#10;                    // 判斷是否為樹葉節點&#10;                    int left = 2 * i + 1;&#10;                    int right = 2 * i + 2;&#10;                    boolean isLeaf = (left &gt;= arr.length || arr[left] == null) &amp;&amp; (right &gt;= arr.length || arr[right] == null);&#10;                    if (isLeaf) {&#10;                        arr[i] = null;&#10;                    } else {&#10;                        // 只將該節點及其子樹設為 null，不重整陣列&#10;                        deleteSubtree(i);&#10;                    }&#10;                }&#10;            }&#10;            repaint();&#10;        });&#10;        randomButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            int n;&#10;            try {&#10;                n = Integer.parseInt(text);&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入有效的整數N&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;                return;&#10;            }&#10;            // 產生不重複的隨機數字&#10;            java.util.Set&lt;Integer&gt; set = new java.util.LinkedHashSet&lt;&gt;();&#10;            java.util.Random rand = new java.util.Random();&#10;            int max = Math.max(n * 2, 100);&#10;            while (set.size() &lt; n) {&#10;                set.add(rand.nextInt(max));&#10;            }&#10;            // 將現有陣列擴充或覆蓋&#10;            arr = set.stream().map(String::valueOf).toArray(String[]::new);&#10;            repaint();&#10;        });&#10;        // 拜訪選項與結果顯示&#10;        inorderBox = new JCheckBox(&quot;Inorder&quot;);&#10;        preorderBox = new JCheckBox(&quot;Preorder&quot;);&#10;        postorderBox = new JCheckBox(&quot;Postorder&quot;);&#10;        traverseButton = new JButton(&quot;拜訪&quot;);&#10;        resultArea = new JTextArea(3, 60);&#10;        resultArea.setEditable(false);&#10;        JPanel traversePanel = new JPanel();&#10;        traversePanel.add(new JLabel(&quot;選擇拜訪方式：&quot;));&#10;        traversePanel.add(inorderBox);&#10;        traversePanel.add(preorderBox);&#10;        traversePanel.add(postorderBox);&#10;        traversePanel.add(traverseButton);&#10;        JPanel bottomPanel = new JPanel();&#10;        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));&#10;        bottomPanel.add(traversePanel);&#10;        bottomPanel.add(new JScrollPane(resultArea));&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;        traverseButton.addActionListener(e -&gt; {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBox.isSelected()) {&#10;                sb.append(&quot;Inorder: &quot;);&#10;                inorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBox.isSelected()) {&#10;                sb.append(&quot;Preorder: &quot;);&#10;                preorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBox.isSelected()) {&#10;                sb.append(&quot;Postorder: &quot;);&#10;                postorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (!inorderBox.isSelected() &amp;&amp; !preorderBox.isSelected() &amp;&amp; !postorderBox.isSelected()) {&#10;                sb.append(&quot;請至少選擇一種拜訪方式！\n&quot;);&#10;            }&#10;            resultArea.setText(sb.toString());&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        drawTree(g, 0, getWidth() / 2 - 15, 80, 120);&#10;    }&#10;&#10;    void drawTree(Graphics g, int index, int x, int y, int xOffset) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        g.drawOval(x, y, 30, 30);&#10;        g.drawString(arr[index], x + 12, y + 20);&#10;        int left = 2 * index + 1;&#10;        if (left &lt; arr.length &amp;&amp; arr[left] != null) {&#10;            g.drawLine(x + 15, y + 30, x - xOffset + 15, y + 80);&#10;            drawTree(g, left, x - xOffset, y + 80, xOffset / 2);&#10;        }&#10;        int right = 2 * index + 2;&#10;        if (right &lt; arr.length &amp;&amp; arr[right] != null) {&#10;            g.drawLine(x + 15, y + 30, x + xOffset + 15, y + 80);&#10;            drawTree(g, right, x + xOffset, y + 80, xOffset / 2);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除子樹&#10;    void deleteSubtree(int index) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        arr[index] = null;&#10;        deleteSubtree(2 * index + 1);&#10;        deleteSubtree(2 * index + 2);&#10;    }&#10;&#10;    // inorder 拜訪&#10;    void inorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        inorder(2 * index + 1, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        inorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // preorder 拜訪&#10;    void preorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        preorder(2 * index + 1, sb);&#10;        preorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // postorder 拜訪&#10;    void postorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        postorder(2 * index + 1, sb);&#10;        postorder(2 * index + 2, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Array Binary Tree Visualization&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(1000, 600);&#10;        frame.add(new ArrayBinaryTreeGUI());&#10;        frame.setVisible(true);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ProducerGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ProducerGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Random;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class ProducerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JTextArea logArea;&#10;    private JPanel bufferPanel;&#10;    private ArrayBlockingQueue&lt;String&gt; buffer;&#10;    private ProducerThread producerThread;&#10;    private ConsumerThread consumerThread;&#10;    private FlowAnimationPanel animationPanel;&#10;&#10;    public ProducerGUI() {&#10;        setTitle(&quot;生產者範例&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(900, 500); // 預設較大視窗&#10;        setMinimumSize(new Dimension(900, 500));&#10;        setLayout(new BorderLayout());&#10;&#10;        // 使用 GridBagLayout 讓上方元件不亂掉&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;Buffer 大小: &quot;), gbc);&#10;        gbc.gridx = 1;&#10;        bufferSizeField = new JTextField(&quot;5&quot;, 5);&#10;        topPanel.add(bufferSizeField, gbc);&#10;        gbc.gridx = 2;&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        topPanel.add(startButton, gbc);&#10;        gbc.gridx = 3;&#10;        gbc.weightx = 1;&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        topPanel.add(Box.createHorizontalGlue(), gbc);&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        bufferPanel = new JPanel();&#10;        bufferPanel.setLayout(new FlowLayout(FlowLayout.LEFT));&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot;Buffer 內容 (數據顯示)&quot;));&#10;        add(bufferPanel, BorderLayout.CENTER);&#10;&#10;        logArea = new JTextArea();&#10;        logArea.setEditable(false);&#10;        add(new JScrollPane(logArea), BorderLayout.EAST);&#10;&#10;        animationPanel = new FlowAnimationPanel();&#10;        animationPanel.setPreferredSize(new Dimension(700, 200)); // 放大動畫區域&#10;        add(animationPanel, BorderLayout.SOUTH);&#10;&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                int n;&#10;                try {&#10;                    n = Integer.parseInt(bufferSizeField.getText());&#10;                    if (n &lt;= 0) throw new NumberFormatException();&#10;                } catch (NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(ProducerGUI.this, &quot;請輸入正整數作為 buffer 大小&quot;);&#10;                    return;&#10;                }&#10;                buffer = new ArrayBlockingQueue&lt;&gt;(n);&#10;                logArea.setText(&quot;&quot;);&#10;                if (producerThread != null &amp;&amp; producerThread.isAlive()) {&#10;                    producerThread.interrupt();&#10;                }&#10;                if (consumerThread != null &amp;&amp; consumerThread.isAlive()) {&#10;                    consumerThread.interrupt();&#10;                }&#10;                producerThread = new ProducerThread();&#10;                consumerThread = new ConsumerThread();&#10;                producerThread.start();&#10;                consumerThread.start();&#10;                startButton.setEnabled(false);&#10;                bufferSizeField.setEnabled(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateBufferPanel(String highlightItem, boolean isProduced) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            bufferPanel.removeAll();&#10;            for (String item : buffer) {&#10;                JLabel label = new JLabel(item);&#10;                label.setOpaque(true);&#10;                label.setBorder(BorderFactory.createLineBorder(Color.GRAY));&#10;                if (item.equals(highlightItem)) {&#10;                    if (isProduced) {&#10;                        label.setBackground(Color.YELLOW);&#10;                    } else {&#10;                        label.setBackground(Color.PINK);&#10;                    }&#10;                } else {&#10;                    label.setBackground(Color.WHITE);&#10;                }&#10;                bufferPanel.add(label);&#10;            }&#10;            bufferPanel.revalidate();&#10;            bufferPanel.repaint();&#10;        });&#10;    }&#10;&#10;    private void animateProduce(String item) {&#10;        animationPanel.animateProduce(item);&#10;    }&#10;    private void animateConsume(String item) {&#10;        animationPanel.animateConsume(item);&#10;    }&#10;&#10;    private class ProducerThread extends Thread {&#10;        private final Random rand = new Random();&#10;        private final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                String item = sdf.format(new Date()) + &quot; 編號:&quot; + (rand.nextInt(900) + 100);&#10;                try {&#10;                    buffer.put(item); // 滿時會阻塞&#10;                    SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;生產: &quot; + item + &quot;\n&quot;));&#10;                    updateBufferPanel(item, true);&#10;                    animateProduce(item);&#10;                    Thread.sleep(200);&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                startButton.setEnabled(true);&#10;                bufferSizeField.setEnabled(true);&#10;            });&#10;        }&#10;    }&#10;&#10;    private class ConsumerThread extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                try {&#10;                    String minItem = null;&#10;                    int minNum = Integer.MAX_VALUE;&#10;                    // 找出最小編號物品&#10;                    synchronized (buffer) {&#10;                        for (String item : buffer) {&#10;                            int idx = item.lastIndexOf(&quot;:&quot;);&#10;                            if (idx != -1) {&#10;                                int num = Integer.parseInt(item.substring(idx + 1));&#10;                                if (num &lt; minNum) {&#10;                                    minNum = num;&#10;                                    minItem = item;&#10;                                }&#10;                            }&#10;                        }&#10;                        if (minItem != null) {&#10;                            buffer.remove(minItem);&#10;                        }&#10;                    }&#10;                    if (minItem != null) {&#10;                        String finalMinItem = minItem;&#10;                        SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;消費: &quot; + finalMinItem + &quot;\n&quot;));&#10;                        updateBufferPanel(finalMinItem, false);&#10;                        animateConsume(finalMinItem);&#10;                    }&#10;                    Thread.sleep(300); // 消費速度可調整&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new ProducerGUI().setVisible(true));&#10;    }&#10;&#10;    // 動畫面板類別&#10;    class FlowAnimationPanel extends JPanel {&#10;        private String animatingItem = null;&#10;        private int animX = 0;&#10;        private int animY = 120;&#10;        private int targetX = 0;&#10;        private boolean isProducing = true;&#10;        private Timer timer;&#10;&#10;        public FlowAnimationPanel() {&#10;            setBackground(Color.WHITE);&#10;        }&#10;&#10;        public void animateProduce(String item) {&#10;            animatingItem = item;&#10;            animX = 60; // 生產者區塊右側&#10;            animY = 120;&#10;            targetX = 320; // buffer 區塊左側&#10;            isProducing = true;&#10;            startAnimation();&#10;        }&#10;        public void animateConsume(String item) {&#10;            animatingItem = item;&#10;            animX = 320 + getBufferItemIndex(item) * 60; // buffer區塊內對應物品位置&#10;            animY = 120;&#10;            targetX = 600; // 消費者區塊左側&#10;            isProducing = false;&#10;            startAnimation();&#10;        }&#10;        private void startAnimation() {&#10;            if (timer != null &amp;&amp; timer.isRunning()) timer.stop();&#10;            timer = new Timer(10, e -&gt; {&#10;                if (isProducing) {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                } else {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            timer.start();&#10;        }&#10;        private int getBufferItemIndex(String item) {&#10;            int idx = 0;&#10;            for (String s : buffer) {&#10;                if (s.equals(item)) return idx;&#10;                idx++;&#10;            }&#10;            return 0;&#10;        }&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // 畫三個區塊&#10;            g.setColor(Color.LIGHT_GRAY);&#10;            g.fillRect(20, 100, 80, 80); // 生產者&#10;            g.fillRect(300, 100, 260, 80); // buffer&#10;            g.fillRect(580, 100, 80, 80); // 消費者&#10;            g.setColor(Color.BLACK);&#10;            g.drawRect(20, 100, 80, 80);&#10;            g.drawRect(300, 100, 260, 80);&#10;            g.drawRect(580, 100, 80, 80);&#10;            g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, 16));&#10;            g.drawString(&quot;生產者&quot;, 30, 95);&#10;            g.drawString(&quot;Buffer&quot;, 390, 95);&#10;            g.drawString(&quot;消費者&quot;, 590, 95);&#10;            // 畫箭頭&#10;            g.drawLine(100, 140, 300, 140);&#10;            g.drawLine(560, 140, 580, 140);&#10;            // 畫 buffer 內所有物品（以圓形+編號顯示）&#10;            int i = 0;&#10;            for (String item : buffer) {&#10;                int x = 320 + i * 60;&#10;                int y = 120;&#10;                g.setColor(Color.CYAN);&#10;                g.fillOval(x, y, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(x, y, 40, 40);&#10;                String num = getItemNumber(item);&#10;                g.drawString(num, x + 10, y + 25);&#10;                i++;&#10;            }&#10;            // 畫動畫物品&#10;            if (animatingItem != null) {&#10;                g.setColor(isProducing ? Color.YELLOW : Color.PINK);&#10;                g.fillOval(animX, animY, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(animX, animY, 40, 40);&#10;                String num = getItemNumber(animatingItem);&#10;                g.drawString(num, animX + 10, animY + 25);&#10;            }&#10;        }&#10;        private String getItemNumber(String item) {&#10;            int idx = item.lastIndexOf(&quot;:&quot;);&#10;            if (idx != -1 &amp;&amp; idx + 1 &lt; item.length()) {&#10;                return item.substring(idx + 1).trim();&#10;            }&#10;            return &quot;?&quot;;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Random;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class ProducerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JTextArea logArea;&#10;    private JPanel bufferPanel;&#10;    private ArrayBlockingQueue&lt;String&gt; buffer;&#10;    private ProducerThread producerThread;&#10;    private ConsumerThread consumerThread;&#10;    private FlowAnimationPanel animationPanel;&#10;&#10;    public ProducerGUI() {&#10;        setTitle(&quot;生產者範例&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(900, 500); // 預設較大視窗&#10;        setMinimumSize(new Dimension(900, 500));&#10;        setLayout(new BorderLayout());&#10;&#10;        // 使用 GridBagLayout 讓上方元件不亂掉，並加大間距&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(10, 10, 10, 10);&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        gbc.anchor = GridBagConstraints.WEST;&#10;        topPanel.add(new JLabel(&quot;Buffer 大小: &quot;), gbc);&#10;        gbc.gridx = 1;&#10;        bufferSizeField = new JTextField(&quot;5&quot;, 8);&#10;        topPanel.add(bufferSizeField, gbc);&#10;        gbc.gridx = 2;&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        topPanel.add(startButton, gbc);&#10;        gbc.gridx = 3;&#10;        gbc.weightx = 1;&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        topPanel.add(Box.createHorizontalGlue(), gbc);&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // bufferPanel 放在上方，顯示 buffer 內容&#10;        bufferPanel = new JPanel();&#10;        bufferPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 15, 15));&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot;Buffer 內容 (數據顯示)&quot;));&#10;        bufferPanel.setPreferredSize(new Dimension(900, 70));&#10;        add(bufferPanel, BorderLayout.CENTER);&#10;&#10;        // logArea 放在右側，寬度限制&#10;        logArea = new JTextArea();&#10;        logArea.setEditable(false);&#10;        JScrollPane logScroll = new JScrollPane(logArea);&#10;        logScroll.setPreferredSize(new Dimension(250, 200));&#10;        add(logScroll, BorderLayout.EAST);&#10;&#10;        animationPanel = new FlowAnimationPanel();&#10;        animationPanel.setPreferredSize(new Dimension(700, 200)); // 放大動畫區域&#10;        add(animationPanel, BorderLayout.SOUTH);&#10;&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                int n;&#10;                try {&#10;                    n = Integer.parseInt(bufferSizeField.getText());&#10;                    if (n &lt;= 0) throw new NumberFormatException();&#10;                } catch (NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(ProducerGUI.this, &quot;請輸入正整數作為 buffer 大小&quot;);&#10;                    return;&#10;                }&#10;                buffer = new ArrayBlockingQueue&lt;&gt;(n);&#10;                logArea.setText(&quot;&quot;);&#10;                if (producerThread != null &amp;&amp; producerThread.isAlive()) {&#10;                    producerThread.interrupt();&#10;                }&#10;                if (consumerThread != null &amp;&amp; consumerThread.isAlive()) {&#10;                    consumerThread.interrupt();&#10;                }&#10;                producerThread = new ProducerThread();&#10;                consumerThread = new ConsumerThread();&#10;                producerThread.start();&#10;                consumerThread.start();&#10;                startButton.setEnabled(false);&#10;                bufferSizeField.setEnabled(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateBufferPanel(String highlightItem, boolean isProduced) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            bufferPanel.removeAll();&#10;            for (String item : buffer) {&#10;                JLabel label = new JLabel(item);&#10;                label.setOpaque(true);&#10;                label.setBorder(BorderFactory.createLineBorder(Color.GRAY));&#10;                if (item.equals(highlightItem)) {&#10;                    if (isProduced) {&#10;                        label.setBackground(Color.YELLOW);&#10;                    } else {&#10;                        label.setBackground(Color.PINK);&#10;                    }&#10;                } else {&#10;                    label.setBackground(Color.WHITE);&#10;                }&#10;                bufferPanel.add(label);&#10;            }&#10;            bufferPanel.revalidate();&#10;            bufferPanel.repaint();&#10;        });&#10;    }&#10;&#10;    private void animateProduce(String item) {&#10;        animationPanel.animateProduce(item);&#10;    }&#10;    private void animateConsume(String item) {&#10;        animationPanel.animateConsume(item);&#10;    }&#10;&#10;    private class ProducerThread extends Thread {&#10;        private final Random rand = new Random();&#10;        private final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                String item = sdf.format(new Date()) + &quot; 編號:&quot; + (rand.nextInt(900) + 100);&#10;                try {&#10;                    buffer.put(item); // 滿時會阻塞&#10;                    SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;生產: &quot; + item + &quot;\n&quot;));&#10;                    updateBufferPanel(item, true);&#10;                    animateProduce(item);&#10;                    Thread.sleep(200);&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                startButton.setEnabled(true);&#10;                bufferSizeField.setEnabled(true);&#10;            });&#10;        }&#10;    }&#10;&#10;    private class ConsumerThread extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                try {&#10;                    String minItem = null;&#10;                    int minNum = Integer.MAX_VALUE;&#10;                    // 找出最小編號物品&#10;                    synchronized (buffer) {&#10;                        for (String item : buffer) {&#10;                            int idx = item.lastIndexOf(&quot;:&quot;);&#10;                            if (idx != -1) {&#10;                                int num = Integer.parseInt(item.substring(idx + 1));&#10;                                if (num &lt; minNum) {&#10;                                    minNum = num;&#10;                                    minItem = item;&#10;                                }&#10;                            }&#10;                        }&#10;                        if (minItem != null) {&#10;                            buffer.remove(minItem);&#10;                        }&#10;                    }&#10;                    if (minItem != null) {&#10;                        String finalMinItem = minItem;&#10;                        SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;消費: &quot; + finalMinItem + &quot;\n&quot;));&#10;                        updateBufferPanel(finalMinItem, false);&#10;                        animateConsume(finalMinItem);&#10;                    }&#10;                    Thread.sleep(300); // 消費速度可調整&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new ProducerGUI().setVisible(true));&#10;    }&#10;&#10;    // 動畫面板類別&#10;    class FlowAnimationPanel extends JPanel {&#10;        private String animatingItem = null;&#10;        private int animX = 0;&#10;        private int animY = 120;&#10;        private int targetX = 0;&#10;        private boolean isProducing = true;&#10;        private Timer timer;&#10;&#10;        public FlowAnimationPanel() {&#10;            setBackground(Color.WHITE);&#10;        }&#10;&#10;        public void animateProduce(String item) {&#10;            animatingItem = item;&#10;            animX = 60; // 生產者區塊右側&#10;            animY = 120;&#10;            targetX = 320; // buffer 區塊左側&#10;            isProducing = true;&#10;            startAnimation();&#10;        }&#10;        public void animateConsume(String item) {&#10;            animatingItem = item;&#10;            animX = 320 + getBufferItemIndex(item) * 60; // buffer區塊內對應物品位置&#10;            animY = 120;&#10;            targetX = 600; // 消費者區塊左側&#10;            isProducing = false;&#10;            startAnimation();&#10;        }&#10;        private void startAnimation() {&#10;            if (timer != null &amp;&amp; timer.isRunning()) timer.stop();&#10;            timer = new Timer(10, e -&gt; {&#10;                if (isProducing) {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                } else {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            timer.start();&#10;        }&#10;        private int getBufferItemIndex(String item) {&#10;            int idx = 0;&#10;            for (String s : buffer) {&#10;                if (s.equals(item)) return idx;&#10;                idx++;&#10;            }&#10;            return 0;&#10;        }&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // 畫三個區塊&#10;            g.setColor(Color.LIGHT_GRAY);&#10;            g.fillRect(20, 100, 80, 80); // 生產者&#10;            g.fillRect(300, 100, 260, 80); // buffer&#10;            g.fillRect(580, 100, 80, 80); // 消費者&#10;            g.setColor(Color.BLACK);&#10;            g.drawRect(20, 100, 80, 80);&#10;            g.drawRect(300, 100, 260, 80);&#10;            g.drawRect(580, 100, 80, 80);&#10;            g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, 16));&#10;            g.drawString(&quot;生產者&quot;, 30, 95);&#10;            g.drawString(&quot;Buffer&quot;, 390, 95);&#10;            g.drawString(&quot;消費者&quot;, 590, 95);&#10;            // 畫箭頭&#10;            g.drawLine(100, 140, 300, 140);&#10;            g.drawLine(560, 140, 580, 140);&#10;            // 畫 buffer 內所有物品（以圓形+編號顯示）&#10;            int i = 0;&#10;            for (String item : buffer) {&#10;                int x = 320 + i * 60;&#10;                int y = 120;&#10;                g.setColor(Color.CYAN);&#10;                g.fillOval(x, y, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(x, y, 40, 40);&#10;                String num = getItemNumber(item);&#10;                g.drawString(num, x + 10, y + 25);&#10;                i++;&#10;            }&#10;            // 畫動畫物品&#10;            if (animatingItem != null) {&#10;                g.setColor(isProducing ? Color.YELLOW : Color.PINK);&#10;                g.fillOval(animX, animY, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(animX, animY, 40, 40);&#10;                String num = getItemNumber(animatingItem);&#10;                g.drawString(num, animX + 10, animY + 25);&#10;            }&#10;        }&#10;        private String getItemNumber(String item) {&#10;            int idx = item.lastIndexOf(&quot;:&quot;);&#10;            if (idx != -1 &amp;&amp; idx + 1 &lt; item.length()) {&#10;                return item.substring(idx + 1).trim();&#10;            }&#10;            return &quot;?&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>