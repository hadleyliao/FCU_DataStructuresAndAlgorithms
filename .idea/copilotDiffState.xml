<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/ArrayBinaryTreeGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ArrayBinaryTreeGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class ArrayBinaryTreeGUI extends JPanel {&#10;    String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;};&#10;    JTextField inputField;&#10;    JButton updateButton;&#10;    JButton deleteButton;&#10;    JButton randomButton;&#10;    JLabel infoLabel;&#10;    JRadioButton inorderButton;&#10;    JRadioButton preorderButton;&#10;    JRadioButton postorderButton;&#10;    JButton traverseButton;&#10;    JTextArea resultArea;&#10;&#10;    public ArrayBinaryTreeGUI() {&#10;        setLayout(new BorderLayout());&#10;        JPanel topPanel = new JPanel();&#10;        inputField = new JTextField(15); // 將欄位長度由30改為15&#10;        updateButton = new JButton(&quot;更新陣列&quot;);&#10;        deleteButton = new JButton(&quot;刪除節點&quot;);&#10;        randomButton = new JButton(&quot;隨機產生N個數字&quot;);&#10;        infoLabel = new JLabel(&quot;請輸入以逗號分隔的節點（如：A,B,C,D,E,F,G）&quot;);&#10;        topPanel.add(infoLabel);&#10;        topPanel.add(inputField);&#10;        topPanel.add(updateButton);&#10;        topPanel.add(deleteButton);&#10;        topPanel.add(randomButton);&#10;        add(topPanel, BorderLayout.NORTH);&#10;        updateButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            if (!text.isEmpty()) {&#10;                arr = text.split(&quot;,&quot;);&#10;                for (int i = 0; i &lt; arr.length; i++) {&#10;                    arr[i] = arr[i].trim();&#10;                    if (arr[i].isEmpty()) arr[i] = null;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;        deleteButton.addActionListener(e -&gt; {&#10;            String key = inputField.getText().trim();&#10;            if (key.isEmpty()) return;&#10;            // 找到所有等於 key 的節點&#10;            for (int i = 0; i &lt; arr.length; i++) {&#10;                if (arr[i] != null &amp;&amp; arr[i].equals(key)) {&#10;                    // 判斷是否為樹葉節點&#10;                    int left = 2 * i + 1;&#10;                    int right = 2 * i + 2;&#10;                    boolean isLeaf = (left &gt;= arr.length || arr[left] == null) &amp;&amp; (right &gt;= arr.length || arr[right] == null);&#10;                    if (isLeaf) {&#10;                        arr[i] = null;&#10;                    } else {&#10;                        // 只將該節點及其子樹設為 null，不重整陣列&#10;                        deleteSubtree(i);&#10;                    }&#10;                }&#10;            }&#10;            repaint();&#10;        });&#10;        randomButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            int n;&#10;            try {&#10;                n = Integer.parseInt(text);&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入有效的整數N&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;                return;&#10;            }&#10;            // 產生不重複的隨機數字&#10;            java.util.Set&lt;Integer&gt; set = new java.util.LinkedHashSet&lt;&gt;();&#10;            java.util.Random rand = new java.util.Random();&#10;            int max = Math.max(n * 2, 100);&#10;            while (set.size() &lt; n) {&#10;                set.add(rand.nextInt(max));&#10;            }&#10;            // 將現有陣列擴充或覆蓋&#10;            arr = set.stream().map(String::valueOf).toArray(String[]::new);&#10;            repaint();&#10;        });&#10;        // 拜訪選項與結果顯示&#10;        inorderButton = new JRadioButton(&quot;Inorder&quot;);&#10;        preorderButton = new JRadioButton(&quot;Preorder&quot;);&#10;        postorderButton = new JRadioButton(&quot;Postorder&quot;);&#10;        traverseButton = new JButton(&quot;拜訪&quot;);&#10;        resultArea = new JTextArea(5, 60);&#10;        resultArea.setEditable(false);&#10;        JPanel traversePanel = new JPanel();&#10;        traversePanel.add(new JLabel(&quot;選擇拜訪方式：&quot;));&#10;        traversePanel.add(inorderButton);&#10;        traversePanel.add(preorderButton);&#10;        traversePanel.add(postorderButton);&#10;        traversePanel.add(traverseButton);&#10;        // add(traversePanel, BorderLayout.CENTER); // 移除這行&#10;        // add(new JScrollPane(resultArea), BorderLayout.SOUTH); // 移除這行&#10;        // 新增一個底層面板，垂直排列樹狀圖與拜訪選項&#10;        JPanel bottomPanel = new JPanel();&#10;        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));&#10;        bottomPanel.add(traversePanel);&#10;        bottomPanel.add(new JScrollPane(resultArea));&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;        traverseButton.addActionListener(e -&gt; {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderButton.isSelected()) {&#10;                sb.append(&quot;Inorder: &quot;);&#10;                inorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (preorderButton.isSelected()) {&#10;                sb.append(&quot;Preorder: &quot;);&#10;                preorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (postorderButton.isSelected()) {&#10;                sb.append(&quot;Postorder: &quot;);&#10;                postorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (!inorderButton.isSelected() &amp;&amp; !preorderButton.isSelected() &amp;&amp; !postorderButton.isSelected()) {&#10;                sb.append(&quot;請至少選擇一種拜訪方式！\n&quot;);&#10;            }&#10;            resultArea.setText(sb.toString());&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        drawTree(g, 0, getWidth() / 2 - 15, 80, 120);&#10;    }&#10;&#10;    void drawTree(Graphics g, int index, int x, int y, int xOffset) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        g.drawOval(x, y, 30, 30);&#10;        g.drawString(arr[index], x + 12, y + 20);&#10;        int left = 2 * index + 1;&#10;        if (left &lt; arr.length &amp;&amp; arr[left] != null) {&#10;            g.drawLine(x + 15, y + 30, x - xOffset + 15, y + 80);&#10;            drawTree(g, left, x - xOffset, y + 80, xOffset / 2);&#10;        }&#10;        int right = 2 * index + 2;&#10;        if (right &lt; arr.length &amp;&amp; arr[right] != null) {&#10;            g.drawLine(x + 15, y + 30, x + xOffset + 15, y + 80);&#10;            drawTree(g, right, x + xOffset, y + 80, xOffset / 2);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除子樹&#10;    void deleteSubtree(int index) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        arr[index] = null;&#10;        deleteSubtree(2 * index + 1);&#10;        deleteSubtree(2 * index + 2);&#10;    }&#10;&#10;    // inorder 拜訪&#10;    void inorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        inorder(2 * index + 1, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        inorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // preorder 拜訪&#10;    void preorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        preorder(2 * index + 1, sb);&#10;        preorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // postorder 拜訪&#10;    void postorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        postorder(2 * index + 1, sb);&#10;        postorder(2 * index + 2, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Array Binary Tree Visualization&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(1000, 600);&#10;        frame.add(new ArrayBinaryTreeGUI());&#10;        frame.setVisible(true);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class ArrayBinaryTreeGUI extends JPanel {&#10;    String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;};&#10;    JTextField inputField;&#10;    JButton updateButton;&#10;    JButton deleteButton;&#10;    JButton randomButton;&#10;    JLabel infoLabel;&#10;    JCheckBox inorderBox;&#10;    JCheckBox preorderBox;&#10;    JCheckBox postorderBox;&#10;    JButton traverseButton;&#10;    JTextArea resultArea;&#10;&#10;    public ArrayBinaryTreeGUI() {&#10;        setLayout(new BorderLayout());&#10;        JPanel topPanel = new JPanel();&#10;        inputField = new JTextField(15); // 將欄位長度由30改為15&#10;        updateButton = new JButton(&quot;更新陣列&quot;);&#10;        deleteButton = new JButton(&quot;刪除節點&quot;);&#10;        randomButton = new JButton(&quot;隨機產生N個數字&quot;);&#10;        infoLabel = new JLabel(&quot;請輸入以逗號分隔的節點（如：A,B,C,D,E,F,G）&quot;);&#10;        topPanel.add(infoLabel);&#10;        topPanel.add(inputField);&#10;        topPanel.add(updateButton);&#10;        topPanel.add(deleteButton);&#10;        topPanel.add(randomButton);&#10;        add(topPanel, BorderLayout.NORTH);&#10;        updateButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            if (!text.isEmpty()) {&#10;                arr = text.split(&quot;,&quot;);&#10;                for (int i = 0; i &lt; arr.length; i++) {&#10;                    arr[i] = arr[i].trim();&#10;                    if (arr[i].isEmpty()) arr[i] = null;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;        deleteButton.addActionListener(e -&gt; {&#10;            String key = inputField.getText().trim();&#10;            if (key.isEmpty()) return;&#10;            // 找到所有等於 key 的節點&#10;            for (int i = 0; i &lt; arr.length; i++) {&#10;                if (arr[i] != null &amp;&amp; arr[i].equals(key)) {&#10;                    // 判斷是否為樹葉節點&#10;                    int left = 2 * i + 1;&#10;                    int right = 2 * i + 2;&#10;                    boolean isLeaf = (left &gt;= arr.length || arr[left] == null) &amp;&amp; (right &gt;= arr.length || arr[right] == null);&#10;                    if (isLeaf) {&#10;                        arr[i] = null;&#10;                    } else {&#10;                        // 只將該節點及其子樹設為 null，不重整陣列&#10;                        deleteSubtree(i);&#10;                    }&#10;                }&#10;            }&#10;            repaint();&#10;        });&#10;        randomButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            int n;&#10;            try {&#10;                n = Integer.parseInt(text);&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入有效的整數N&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;                return;&#10;            }&#10;            // 產生不重複的隨機數字&#10;            java.util.Set&lt;Integer&gt; set = new java.util.LinkedHashSet&lt;&gt;();&#10;            java.util.Random rand = new java.util.Random();&#10;            int max = Math.max(n * 2, 100);&#10;            while (set.size() &lt; n) {&#10;                set.add(rand.nextInt(max));&#10;            }&#10;            // 將現有陣列擴充或覆蓋&#10;            arr = set.stream().map(String::valueOf).toArray(String[]::new);&#10;            repaint();&#10;        });&#10;        // 拜訪選項與結果顯示&#10;        inorderBox = new JCheckBox(&quot;Inorder&quot;);&#10;        preorderBox = new JCheckBox(&quot;Preorder&quot;);&#10;        postorderBox = new JCheckBox(&quot;Postorder&quot;);&#10;        traverseButton = new JButton(&quot;拜訪&quot;);&#10;        resultArea = new JTextArea(3, 60);&#10;        resultArea.setEditable(false);&#10;        JPanel traversePanel = new JPanel();&#10;        traversePanel.add(new JLabel(&quot;選擇拜訪方式：&quot;));&#10;        traversePanel.add(inorderBox);&#10;        traversePanel.add(preorderBox);&#10;        traversePanel.add(postorderBox);&#10;        traversePanel.add(traverseButton);&#10;        JPanel bottomPanel = new JPanel();&#10;        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));&#10;        bottomPanel.add(traversePanel);&#10;        bottomPanel.add(new JScrollPane(resultArea));&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;        traverseButton.addActionListener(e -&gt; {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBox.isSelected()) {&#10;                sb.append(&quot;Inorder: &quot;);&#10;                inorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBox.isSelected()) {&#10;                sb.append(&quot;Preorder: &quot;);&#10;                preorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBox.isSelected()) {&#10;                sb.append(&quot;Postorder: &quot;);&#10;                postorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (!inorderBox.isSelected() &amp;&amp; !preorderBox.isSelected() &amp;&amp; !postorderBox.isSelected()) {&#10;                sb.append(&quot;請至少選擇一種拜訪方式！\n&quot;);&#10;            }&#10;            resultArea.setText(sb.toString());&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        drawTree(g, 0, getWidth() / 2 - 15, 80, 120);&#10;    }&#10;&#10;    void drawTree(Graphics g, int index, int x, int y, int xOffset) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        g.drawOval(x, y, 30, 30);&#10;        g.drawString(arr[index], x + 12, y + 20);&#10;        int left = 2 * index + 1;&#10;        if (left &lt; arr.length &amp;&amp; arr[left] != null) {&#10;            g.drawLine(x + 15, y + 30, x - xOffset + 15, y + 80);&#10;            drawTree(g, left, x - xOffset, y + 80, xOffset / 2);&#10;        }&#10;        int right = 2 * index + 2;&#10;        if (right &lt; arr.length &amp;&amp; arr[right] != null) {&#10;            g.drawLine(x + 15, y + 30, x + xOffset + 15, y + 80);&#10;            drawTree(g, right, x + xOffset, y + 80, xOffset / 2);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除子樹&#10;    void deleteSubtree(int index) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        arr[index] = null;&#10;        deleteSubtree(2 * index + 1);&#10;        deleteSubtree(2 * index + 2);&#10;    }&#10;&#10;    // inorder 拜訪&#10;    void inorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        inorder(2 * index + 1, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        inorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // preorder 拜訪&#10;    void preorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        preorder(2 * index + 1, sb);&#10;        preorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // postorder 拜訪&#10;    void postorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        postorder(2 * index + 1, sb);&#10;        postorder(2 * index + 2, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Array Binary Tree Visualization&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(1000, 600);&#10;        frame.add(new ArrayBinaryTreeGUI());&#10;        frame.setVisible(true);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/GraphGenerator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GraphGenerator.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class GraphGenerator extends JFrame {&#10;    private JTextField vertexField;&#10;    private JTextField edgeField;&#10;    private JButton generateButton;&#10;    private GraphPanel graphPanel;&#10;    private JTextArea vertexInfoArea;&#10;    private JTextArea edgeInfoArea;&#10;&#10;    public GraphGenerator() {&#10;        setTitle(&quot;圖形生成器 - Graph Generator with Cost&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // 創建控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.setBorder(BorderFactory.createTitledBorder(&quot;設定參數&quot;));&#10;&#10;        controlPanel.add(new JLabel(&quot;頂點數量:&quot;));&#10;        vertexField = new JTextField(&quot;5&quot;, 5);&#10;        controlPanel.add(vertexField);&#10;&#10;        controlPanel.add(new JLabel(&quot;邊數量:&quot;));&#10;        edgeField = new JTextField(&quot;7&quot;, 5);&#10;        controlPanel.add(edgeField);&#10;&#10;        generateButton = new JButton(&quot;開始畫圖&quot;);&#10;        generateButton.addActionListener(new GenerateButtonListener());&#10;        controlPanel.add(generateButton);&#10;&#10;        // 創建主要內容面板&#10;        JPanel mainPanel = new JPanel(new BorderLayout());&#10;&#10;        // 創建繪圖面板&#10;        graphPanel = new GraphPanel();&#10;        graphPanel.setPreferredSize(new Dimension(600, 500));&#10;&#10;        // 創建資訊顯示面板&#10;        JPanel infoPanel = new JPanel(new GridLayout(2, 1));&#10;        infoPanel.setPreferredSize(new Dimension(300, 500));&#10;&#10;        // 頂點資訊區域&#10;        JPanel vertexPanel = new JPanel(new BorderLayout());&#10;        vertexPanel.setBorder(BorderFactory.createTitledBorder(&quot;頂點資訊&quot;));&#10;        vertexInfoArea = new JTextArea();&#10;        vertexInfoArea.setEditable(false);&#10;        vertexInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane vertexScrollPane = new JScrollPane(vertexInfoArea);&#10;        vertexScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        vertexPanel.add(vertexScrollPane, BorderLayout.CENTER);&#10;&#10;        // 邊資訊區域&#10;        JPanel edgePanel = new JPanel(new BorderLayout());&#10;        edgePanel.setBorder(BorderFactory.createTitledBorder(&quot;邊資訊 (包含成本)&quot;));&#10;        edgeInfoArea = new JTextArea();&#10;        edgeInfoArea.setEditable(false);&#10;        edgeInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane edgeScrollPane = new JScrollPane(edgeInfoArea);&#10;        edgeScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        edgePanel.add(edgeScrollPane, BorderLayout.CENTER);&#10;&#10;        infoPanel.add(vertexPanel);&#10;        infoPanel.add(edgePanel);&#10;&#10;        mainPanel.add(graphPanel, BorderLayout.CENTER);&#10;        mainPanel.add(infoPanel, BorderLayout.EAST);&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(mainPanel, BorderLayout.CENTER);&#10;&#10;        setSize(950, 600);&#10;        setLocationRelativeTo(null);&#10;&#10;        // 初始化資訊顯示&#10;        updateInfoDisplay();&#10;    }&#10;&#10;    private class GenerateButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            try {&#10;                int vertexCount = Integer.parseInt(vertexField.getText());&#10;                int edgeCount = Integer.parseInt(edgeField.getText());&#10;&#10;                if (vertexCount &lt; 1) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;頂點數量必須至少為1&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                int maxEdges = vertexCount * (vertexCount - 1) / 2; // 完全圖的最大邊數&#10;                if (edgeCount &lt; 0 || edgeCount &gt; maxEdges) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;邊數量必須在0到&quot; + maxEdges + &quot;之間&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                graphPanel.generateGraph(vertexCount, edgeCount);&#10;                updateInfoDisplay();&#10;&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                        &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateInfoDisplay() {&#10;        // 更新頂點資訊&#10;        StringBuilder vertexInfo = new StringBuilder();&#10;        List&lt;Vertex&gt; vertices = graphPanel.getVertices();&#10;&#10;        if (vertices.isEmpty()) {&#10;            vertexInfo.append(&quot;尚未生成圖形\n&quot;);&#10;            vertexInfo.append(&quot;請設定參數後點擊「開始畫圖」&quot;);&#10;        } else {&#10;            vertexInfo.append(&quot;頂點總數: &quot;).append(vertices.size()).append(&quot;\n\n&quot;);&#10;            vertexInfo.append(&quot;頂點列表:\n&quot;);&#10;            vertexInfo.append(&quot;ID  座標(X, Y)\n&quot;);&#10;            vertexInfo.append(&quot;================\n&quot;);&#10;            for (Vertex vertex : vertices) {&#10;                vertexInfo.append(String.format(&quot;V%-2d (%3d, %3d)\n&quot;,&#10;                        vertex.id, vertex.x, vertex.y));&#10;            }&#10;        }&#10;        vertexInfoArea.setText(vertexInfo.toString());&#10;&#10;        // 更新邊資訊&#10;        StringBuilder edgeInfo = new StringBuilder();&#10;        List&lt;Edge&gt; edges = graphPanel.getEdges();&#10;&#10;        if (edges.isEmpty() &amp;&amp; !vertices.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: 0\n\n&quot;);&#10;            edgeInfo.append(&quot;無邊連接&quot;);&#10;        } else if (!edges.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: &quot;).append(edges.size()).append(&quot;\n\n&quot;);&#10;            edgeInfo.append(&quot;邊列表 (雙向):\n&quot;);&#10;            edgeInfo.append(&quot;邊      成本\n&quot;);&#10;            edgeInfo.append(&quot;================\n&quot;);&#10;            for (Edge edge : edges) {&#10;                edgeInfo.append(String.format(&quot;V%d-V%d   %2d\n&quot;,&#10;                        edge.from.id, edge.to.id, edge.cost));&#10;            }&#10;&#10;            // 計算總成本&#10;            int totalCost = edges.stream().mapToInt(edge -&gt; edge.cost).sum();&#10;            edgeInfo.append(&quot;\n總成本: &quot;).append(totalCost);&#10;        } else {&#10;            edgeInfo.append(&quot;尚未生成圖形&quot;);&#10;        }&#10;        edgeInfoArea.setText(edgeInfo.toString());&#10;    }&#10;&#10;    private class GraphPanel extends JPanel {&#10;        private List&lt;Vertex&gt; vertices;&#10;        private List&lt;Edge&gt; edges;&#10;        private Random random;&#10;&#10;        public GraphPanel() {&#10;            setBackground(Color.WHITE);&#10;            setBorder(BorderFactory.createTitledBorder(&quot;圖形顯示區&quot;));&#10;            vertices = new ArrayList&lt;&gt;();&#10;            edges = new ArrayList&lt;&gt;();&#10;            random = new Random();&#10;        }&#10;&#10;        public List&lt;Vertex&gt; getVertices() {&#10;            return new ArrayList&lt;&gt;(vertices);&#10;        }&#10;&#10;        public List&lt;Edge&gt; getEdges() {&#10;            return new ArrayList&lt;&gt;(edges);&#10;        }&#10;&#10;        public void generateGraph(int vertexCount, int edgeCount) {&#10;            vertices.clear();&#10;            edges.clear();&#10;&#10;            // 生成頂點位置（圓形排列）&#10;            int centerX = getWidth() / 2;&#10;            int centerY = getHeight() / 2;&#10;            int radius = Math.min(centerX, centerY) - 100;&#10;&#10;            for (int i = 0; i &lt; vertexCount; i++) {&#10;                double angle = 2 * Math.PI * i / vertexCount;&#10;                int x = centerX + (int)(radius * Math.cos(angle));&#10;                int y = centerY + (int)(radius * Math.sin(angle));&#10;                vertices.add(new Vertex(i, x, y));&#10;            }&#10;&#10;            // 生成無向邊（雙向但只建立一次）&#10;            Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;            int edgesAdded = 0;&#10;&#10;            while (edgesAdded &lt; edgeCount &amp;&amp; edgeSet.size() &lt; vertexCount * (vertexCount - 1) / 2) {&#10;                int from = random.nextInt(vertexCount);&#10;                int to = random.nextInt(vertexCount);&#10;&#10;                if (from != to) {&#10;                    // 確保較小的ID在前面，避免重複邊&#10;                    int minId = Math.min(from, to);&#10;                    int maxId = Math.max(from, to);&#10;                    String edgeKey = minId + &quot;-&quot; + maxId;&#10;&#10;                    if (!edgeSet.contains(edgeKey)) {&#10;                        edgeSet.add(edgeKey);&#10;                        int cost = random.nextInt(99) + 1; // 1-99之間的隨機成本&#10;                        edges.add(new Edge(vertices.get(minId), vertices.get(maxId), cost));&#10;                        edgesAdded++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            repaint();&#10;        }&#10;&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            Graphics2D g2d = (Graphics2D) g;&#10;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;            if (vertices.isEmpty()) {&#10;                // 顯示提示文字&#10;                g2d.setColor(Color.GRAY);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 18));&#10;                String message = &quot;請設定頂點和邊的數量&quot;;&#10;                String message2 = &quot;然後點擊「開始畫圖」&quot;;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int x1 = (getWidth() - fm.stringWidth(message)) / 2;&#10;                int x2 = (getWidth() - fm.stringWidth(message2)) / 2;&#10;                int y = getHeight() / 2 - 15;&#10;                g2d.drawString(message, x1, y);&#10;                g2d.drawString(message2, x2, y + 30);&#10;                return;&#10;            }&#10;&#10;            // 繪製邊和成本標籤&#10;            g2d.setColor(Color.BLUE);&#10;            g2d.setStroke(new BasicStroke(2));&#10;            for (Edge edge : edges) {&#10;                // 繪製邊&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;&#10;                // 計算邊的中點位置&#10;                int midX = (edge.from.x + edge.to.x) / 2;&#10;                int midY = (edge.from.y + edge.to.y) / 2;&#10;&#10;                // 繪製成本標籤背景&#10;                g2d.setColor(Color.YELLOW);&#10;                g2d.fillRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本標籤邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(1));&#10;                g2d.drawRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本數字&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;                String costText = String.valueOf(edge.cost);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int textX = midX - fm.stringWidth(costText) / 2;&#10;                int textY = midY + fm.getAscent() / 2;&#10;                g2d.drawString(costText, textX, textY);&#10;&#10;                // 重設顏色和筆觸以繪製下一條邊&#10;                g2d.setColor(Color.BLUE);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;&#10;            // 繪製頂點&#10;            for (Vertex vertex : vertices) {&#10;                // 繪製頂點圓圈&#10;                g2d.setColor(Color.RED);&#10;                g2d.fillOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;                g2d.drawOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點標籤&#10;                g2d.setColor(Color.WHITE);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                String label = &quot;V&quot; + vertex.id;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int labelX = vertex.x - fm.stringWidth(label) / 2;&#10;                int labelY = vertex.y + fm.getAscent() / 2;&#10;                g2d.drawString(label, labelX, labelY);&#10;            }&#10;&#10;            // 顯示統計信息（放在右上角避免重疊）&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 14));&#10;            g2d.fillRect(getWidth() - 160, 5, 155, 50);&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.fillRect(getWidth() - 158, 7, 151, 46);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.drawString(&quot;頂點: &quot; + vertices.size() + &quot;  邊: &quot; + edges.size(), getWidth() - 150, 25);&#10;            if (!edges.isEmpty()) {&#10;                int totalCost = edges.stream().mapToInt(edge -&gt; edge.cost).sum();&#10;                g2d.drawString(&quot;總成本: &quot; + totalCost, getWidth() - 150, 45);&#10;            }&#10;        }&#10;    }&#10;&#10;    private class Vertex {&#10;        int id;&#10;        int x, y;&#10;&#10;        public Vertex(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    private class Edge {&#10;        Vertex from, to;&#10;        int cost;&#10;&#10;        public Edge(Vertex from, Vertex to, int cost) {&#10;            this.from = from;&#10;            this.to = to;&#10;            this.cost = cost;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeel());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;&#10;            new GraphGenerator().setVisible(true);&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class GraphGenerator extends JFrame {&#10;    private JTextField vertexField;&#10;    private JTextField edgeField;&#10;    private JButton generateButton;&#10;    private GraphPanel graphPanel;&#10;    private JTextArea vertexInfoArea;&#10;    private JTextArea edgeInfoArea;&#10;&#10;    public GraphGenerator() {&#10;        setTitle(&quot;圖形生成器 - Graph Generator with Cost&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // 創建控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.setBorder(BorderFactory.createTitledBorder(&quot;設定參數&quot;));&#10;&#10;        controlPanel.add(new JLabel(&quot;頂點數量:&quot;));&#10;        vertexField = new JTextField(&quot;5&quot;, 5);&#10;        controlPanel.add(vertexField);&#10;&#10;        controlPanel.add(new JLabel(&quot;邊數量:&quot;));&#10;        edgeField = new JTextField(&quot;7&quot;, 5);&#10;        controlPanel.add(edgeField);&#10;&#10;        generateButton = new JButton(&quot;開始畫圖&quot;);&#10;        generateButton.addActionListener(new GenerateButtonListener());&#10;        controlPanel.add(generateButton);&#10;&#10;        // 創建主要內容面板&#10;        JPanel mainPanel = new JPanel(new BorderLayout());&#10;&#10;        // 創建繪圖面板&#10;        graphPanel = new GraphPanel();&#10;        graphPanel.setPreferredSize(new Dimension(600, 500));&#10;&#10;        // 創建資訊顯示面板&#10;        JPanel infoPanel = new JPanel(new GridLayout(2, 1));&#10;        infoPanel.setPreferredSize(new Dimension(300, 500));&#10;&#10;        // 頂點資訊區域&#10;        JPanel vertexPanel = new JPanel(new BorderLayout());&#10;        vertexPanel.setBorder(BorderFactory.createTitledBorder(&quot;頂點資訊&quot;));&#10;        vertexInfoArea = new JTextArea();&#10;        vertexInfoArea.setEditable(false);&#10;        vertexInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane vertexScrollPane = new JScrollPane(vertexInfoArea);&#10;        vertexScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        vertexPanel.add(vertexScrollPane, BorderLayout.CENTER);&#10;&#10;        // 邊資訊區域&#10;        JPanel edgePanel = new JPanel(new BorderLayout());&#10;        edgePanel.setBorder(BorderFactory.createTitledBorder(&quot;邊資訊 (包含成本)&quot;));&#10;        edgeInfoArea = new JTextArea();&#10;        edgeInfoArea.setEditable(false);&#10;        edgeInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane edgeScrollPane = new JScrollPane(edgeInfoArea);&#10;        edgeScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        edgePanel.add(edgeScrollPane, BorderLayout.CENTER);&#10;&#10;        infoPanel.add(vertexPanel);&#10;        infoPanel.add(edgePanel);&#10;&#10;        mainPanel.add(graphPanel, BorderLayout.CENTER);&#10;        mainPanel.add(infoPanel, BorderLayout.EAST);&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(mainPanel, BorderLayout.CENTER);&#10;&#10;        setSize(950, 600);&#10;        setLocationRelativeTo(null);&#10;&#10;        // 初始化資訊顯示&#10;        updateInfoDisplay();&#10;    }&#10;&#10;    private class GenerateButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            try {&#10;                int vertexCount = Integer.parseInt(vertexField.getText());&#10;                int edgeCount = Integer.parseInt(edgeField.getText());&#10;&#10;                if (vertexCount &lt; 1) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;頂點數量必須至少為1&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                int maxEdges = vertexCount * (vertexCount - 1) / 2; // 完全圖的最大邊數&#10;                if (edgeCount &lt; 0 || edgeCount &gt; maxEdges) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;邊數量必須在0到&quot; + maxEdges + &quot;之間&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                graphPanel.generateGraph(vertexCount, edgeCount);&#10;                updateInfoDisplay();&#10;&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                        &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateInfoDisplay() {&#10;        // 更新頂點資訊&#10;        StringBuilder vertexInfo = new StringBuilder();&#10;        List&lt;Vertex&gt; vertices = graphPanel.getVertices();&#10;&#10;        if (vertices.isEmpty()) {&#10;            vertexInfo.append(&quot;尚未生成圖形\n&quot;);&#10;            vertexInfo.append(&quot;請設定參數後點擊「開始畫圖」&quot;);&#10;        } else {&#10;            vertexInfo.append(&quot;頂點總數: &quot;).append(vertices.size()).append(&quot;\n\n&quot;);&#10;            vertexInfo.append(&quot;頂點列表:\n&quot;);&#10;            vertexInfo.append(&quot;ID  座標(X, Y)\n&quot;);&#10;            vertexInfo.append(&quot;================\n&quot;);&#10;            for (Vertex vertex : vertices) {&#10;                vertexInfo.append(String.format(&quot;V%-2d (%3d, %3d)\n&quot;,&#10;                        vertex.id, vertex.x, vertex.y));&#10;            }&#10;        }&#10;        vertexInfoArea.setText(vertexInfo.toString());&#10;&#10;        // 更新邊資訊&#10;        StringBuilder edgeInfo = new StringBuilder();&#10;        List&lt;Edge&gt; edges = graphPanel.getEdges();&#10;&#10;        if (edges.isEmpty() &amp;&amp; !vertices.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: 0\n\n&quot;);&#10;            edgeInfo.append(&quot;無邊連接&quot;);&#10;        } else if (!edges.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: &quot;).append(edges.size()).append(&quot;\n\n&quot;);&#10;            edgeInfo.append(&quot;邊列表 (雙向):\n&quot;);&#10;            edgeInfo.append(&quot;邊      成本\n&quot;);&#10;            edgeInfo.append(&quot;================\n&quot;);&#10;            for (Edge edge : edges) {&#10;                edgeInfo.append(String.format(&quot;V%d-V%d   %2d\n&quot;,&#10;                        edge.from.id, edge.to.id, edge.cost));&#10;            }&#10;&#10;            // 計算總成本&#10;            int totalCost = edges.stream().mapToInt(edge -&gt; edge.cost).sum();&#10;            edgeInfo.append(&quot;\n總成本: &quot;).append(totalCost);&#10;        } else {&#10;            edgeInfo.append(&quot;尚未生成圖形&quot;);&#10;        }&#10;        edgeInfoArea.setText(edgeInfo.toString());&#10;    }&#10;&#10;    private class GraphPanel extends JPanel {&#10;        private List&lt;Vertex&gt; vertices;&#10;        private List&lt;Edge&gt; edges;&#10;        private Random random;&#10;&#10;        public GraphPanel() {&#10;            setBackground(Color.WHITE);&#10;            setBorder(BorderFactory.createTitledBorder(&quot;圖形顯示區&quot;));&#10;            vertices = new ArrayList&lt;&gt;();&#10;            edges = new ArrayList&lt;&gt;();&#10;            random = new Random();&#10;        }&#10;&#10;        public List&lt;Vertex&gt; getVertices() {&#10;            return new ArrayList&lt;&gt;(vertices);&#10;        }&#10;&#10;        public List&lt;Edge&gt; getEdges() {&#10;            return new ArrayList&lt;&gt;(edges);&#10;        }&#10;&#10;        public void generateGraph(int vertexCount, int edgeCount) {&#10;            vertices.clear();&#10;            edges.clear();&#10;&#10;            // 生成頂點位置（圓形排列）&#10;            int centerX = getWidth() / 2;&#10;            int centerY = getHeight() / 2;&#10;            int radius = Math.min(centerX, centerY) - 100;&#10;&#10;            for (int i = 0; i &lt; vertexCount; i++) {&#10;                double angle = 2 * Math.PI * i / vertexCount;&#10;                int x = centerX + (int)(radius * Math.cos(angle));&#10;                int y = centerY + (int)(radius * Math.sin(angle));&#10;                vertices.add(new Vertex(i, x, y));&#10;            }&#10;&#10;            // 生成無向邊（雙向但只建立一次）&#10;            Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;            int edgesAdded = 0;&#10;&#10;            while (edgesAdded &lt; edgeCount &amp;&amp; edgeSet.size() &lt; vertexCount * (vertexCount - 1) / 2) {&#10;                int from = random.nextInt(vertexCount);&#10;                int to = random.nextInt(vertexCount);&#10;&#10;                if (from != to) {&#10;                    // 確保較小的ID在前面，避免重複邊&#10;                    int minId = Math.min(from, to);&#10;                    int maxId = Math.max(from, to);&#10;                    String edgeKey = minId + &quot;-&quot; + maxId;&#10;&#10;                    if (!edgeSet.contains(edgeKey)) {&#10;                        edgeSet.add(edgeKey);&#10;                        int cost = random.nextInt(99) + 1; // 1-99之間的隨機成本&#10;                        edges.add(new Edge(vertices.get(minId), vertices.get(maxId), cost));&#10;                        edgesAdded++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            repaint();&#10;        }&#10;&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            Graphics2D g2d = (Graphics2D) g;&#10;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;            if (vertices.isEmpty()) {&#10;                // 顯示提示文字&#10;                g2d.setColor(Color.GRAY);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 18));&#10;                String message = &quot;請設定頂點和邊的數量&quot;;&#10;                String message2 = &quot;然後點擊「開始畫圖」&quot;;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int x1 = (getWidth() - fm.stringWidth(message)) / 2;&#10;                int x2 = (getWidth() - fm.stringWidth(message2)) / 2;&#10;                int y = getHeight() / 2 - 15;&#10;                g2d.drawString(message, x1, y);&#10;                g2d.drawString(message2, x2, y + 30);&#10;                return;&#10;            }&#10;&#10;            // 繪製邊和成本標籤&#10;            g2d.setColor(Color.BLUE);&#10;            g2d.setStroke(new BasicStroke(2));&#10;            for (Edge edge : edges) {&#10;                // 繪製邊&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;&#10;                // 計算邊的中點位置&#10;                int midX = (edge.from.x + edge.to.x) / 2;&#10;                int midY = (edge.from.y + edge.to.y) / 2;&#10;&#10;                // 繪製成本標籤背景&#10;                g2d.setColor(Color.YELLOW);&#10;                g2d.fillRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本標籤邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(1));&#10;                g2d.drawRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本數字&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;                String costText = String.valueOf(edge.cost);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int textX = midX - fm.stringWidth(costText) / 2;&#10;                int textY = midY + fm.getAscent() / 2;&#10;                g2d.drawString(costText, textX, textY);&#10;&#10;                // 重設顏色和筆觸以繪製下一條邊&#10;                g2d.setColor(Color.BLUE);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;&#10;            // 繪製頂點&#10;            for (Vertex vertex : vertices) {&#10;                // 繪製頂點圓圈&#10;                g2d.setColor(Color.RED);&#10;                g2d.fillOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;                g2d.drawOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點標籤&#10;                g2d.setColor(Color.WHITE);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                String label = &quot;V&quot; + vertex.id;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int labelX = vertex.x - fm.stringWidth(label) / 2;&#10;                int labelY = vertex.y + fm.getAscent() / 2;&#10;                g2d.drawString(label, labelX, labelY);&#10;            }&#10;&#10;            // 顯示統計信息（放在右上角避免重疊）&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 14));&#10;            g2d.fillRect(getWidth() - 160, 5, 155, 50);&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.fillRect(getWidth() - 158, 7, 151, 46);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.drawString(&quot;頂點: &quot; + vertices.size() + &quot;  邊: &quot; + edges.size(), getWidth() - 150, 25);&#10;            if (!edges.isEmpty()) {&#10;                int totalCost = edges.stream().mapToInt(edge -&gt; edge.cost).sum();&#10;                g2d.drawString(&quot;總成本: &quot; + totalCost, getWidth() - 150, 45);&#10;            }&#10;        }&#10;    }&#10;&#10;    private class Vertex {&#10;        int id;&#10;        int x, y;&#10;&#10;        public Vertex(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    private class Edge {&#10;        Vertex from, to;&#10;        int cost;&#10;&#10;        public Edge(Vertex from, Vertex to, int cost) {&#10;            this.from = from;&#10;            this.to = to;&#10;            this.cost = cost;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;&#10;            new GraphGenerator().setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ProducerGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ProducerGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Random;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class ProducerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JTextArea logArea;&#10;    private JPanel bufferPanel;&#10;    private ArrayBlockingQueue&lt;String&gt; buffer;&#10;    private ProducerThread producerThread;&#10;    private ConsumerThread consumerThread;&#10;    private FlowAnimationPanel animationPanel;&#10;&#10;    public ProducerGUI() {&#10;        setTitle(&quot;生產者範例&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(900, 500); // 預設較大視窗&#10;        setMinimumSize(new Dimension(900, 500));&#10;        setLayout(new BorderLayout());&#10;&#10;        // 使用 GridBagLayout 讓上方元件不亂掉&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;Buffer 大小: &quot;), gbc);&#10;        gbc.gridx = 1;&#10;        bufferSizeField = new JTextField(&quot;5&quot;, 5);&#10;        topPanel.add(bufferSizeField, gbc);&#10;        gbc.gridx = 2;&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        topPanel.add(startButton, gbc);&#10;        gbc.gridx = 3;&#10;        gbc.weightx = 1;&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        topPanel.add(Box.createHorizontalGlue(), gbc);&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        bufferPanel = new JPanel();&#10;        bufferPanel.setLayout(new FlowLayout(FlowLayout.LEFT));&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot;Buffer 內容 (數據顯示)&quot;));&#10;        add(bufferPanel, BorderLayout.CENTER);&#10;&#10;        logArea = new JTextArea();&#10;        logArea.setEditable(false);&#10;        add(new JScrollPane(logArea), BorderLayout.EAST);&#10;&#10;        animationPanel = new FlowAnimationPanel();&#10;        animationPanel.setPreferredSize(new Dimension(700, 200)); // 放大動畫區域&#10;        add(animationPanel, BorderLayout.SOUTH);&#10;&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                int n;&#10;                try {&#10;                    n = Integer.parseInt(bufferSizeField.getText());&#10;                    if (n &lt;= 0) throw new NumberFormatException();&#10;                } catch (NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(ProducerGUI.this, &quot;請輸入正整數作為 buffer 大小&quot;);&#10;                    return;&#10;                }&#10;                buffer = new ArrayBlockingQueue&lt;&gt;(n);&#10;                logArea.setText(&quot;&quot;);&#10;                if (producerThread != null &amp;&amp; producerThread.isAlive()) {&#10;                    producerThread.interrupt();&#10;                }&#10;                if (consumerThread != null &amp;&amp; consumerThread.isAlive()) {&#10;                    consumerThread.interrupt();&#10;                }&#10;                producerThread = new ProducerThread();&#10;                consumerThread = new ConsumerThread();&#10;                producerThread.start();&#10;                consumerThread.start();&#10;                startButton.setEnabled(false);&#10;                bufferSizeField.setEnabled(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateBufferPanel(String highlightItem, boolean isProduced) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            bufferPanel.removeAll();&#10;            for (String item : buffer) {&#10;                JLabel label = new JLabel(item);&#10;                label.setOpaque(true);&#10;                label.setBorder(BorderFactory.createLineBorder(Color.GRAY));&#10;                if (item.equals(highlightItem)) {&#10;                    if (isProduced) {&#10;                        label.setBackground(Color.YELLOW);&#10;                    } else {&#10;                        label.setBackground(Color.PINK);&#10;                    }&#10;                } else {&#10;                    label.setBackground(Color.WHITE);&#10;                }&#10;                bufferPanel.add(label);&#10;            }&#10;            bufferPanel.revalidate();&#10;            bufferPanel.repaint();&#10;        });&#10;    }&#10;&#10;    private void animateProduce(String item) {&#10;        animationPanel.animateProduce(item);&#10;    }&#10;    private void animateConsume(String item) {&#10;        animationPanel.animateConsume(item);&#10;    }&#10;&#10;    private class ProducerThread extends Thread {&#10;        private final Random rand = new Random();&#10;        private final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                String item = sdf.format(new Date()) + &quot; 編號:&quot; + (rand.nextInt(900) + 100);&#10;                try {&#10;                    buffer.put(item); // 滿時會阻塞&#10;                    SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;生產: &quot; + item + &quot;\n&quot;));&#10;                    updateBufferPanel(item, true);&#10;                    animateProduce(item);&#10;                    Thread.sleep(200);&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                startButton.setEnabled(true);&#10;                bufferSizeField.setEnabled(true);&#10;            });&#10;        }&#10;    }&#10;&#10;    private class ConsumerThread extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                try {&#10;                    String minItem = null;&#10;                    int minNum = Integer.MAX_VALUE;&#10;                    // 找出最小編號物品&#10;                    synchronized (buffer) {&#10;                        for (String item : buffer) {&#10;                            int idx = item.lastIndexOf(&quot;:&quot;);&#10;                            if (idx != -1) {&#10;                                int num = Integer.parseInt(item.substring(idx + 1));&#10;                                if (num &lt; minNum) {&#10;                                    minNum = num;&#10;                                    minItem = item;&#10;                                }&#10;                            }&#10;                        }&#10;                        if (minItem != null) {&#10;                            buffer.remove(minItem);&#10;                        }&#10;                    }&#10;                    if (minItem != null) {&#10;                        String finalMinItem = minItem;&#10;                        SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;消費: &quot; + finalMinItem + &quot;\n&quot;));&#10;                        updateBufferPanel(finalMinItem, false);&#10;                        animateConsume(finalMinItem);&#10;                    }&#10;                    Thread.sleep(300); // 消費速度可調整&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new ProducerGUI().setVisible(true));&#10;    }&#10;&#10;    // 動畫面板類別&#10;    class FlowAnimationPanel extends JPanel {&#10;        private String animatingItem = null;&#10;        private int animX = 0;&#10;        private int animY = 120;&#10;        private int targetX = 0;&#10;        private boolean isProducing = true;&#10;        private Timer timer;&#10;&#10;        public FlowAnimationPanel() {&#10;            setBackground(Color.WHITE);&#10;        }&#10;&#10;        public void animateProduce(String item) {&#10;            animatingItem = item;&#10;            animX = 60; // 生產者區塊右側&#10;            animY = 120;&#10;            targetX = 320; // buffer 區塊左側&#10;            isProducing = true;&#10;            startAnimation();&#10;        }&#10;        public void animateConsume(String item) {&#10;            animatingItem = item;&#10;            animX = 320 + getBufferItemIndex(item) * 60; // buffer區塊內對應物品位置&#10;            animY = 120;&#10;            targetX = 600; // 消費者區塊左側&#10;            isProducing = false;&#10;            startAnimation();&#10;        }&#10;        private void startAnimation() {&#10;            if (timer != null &amp;&amp; timer.isRunning()) timer.stop();&#10;            timer = new Timer(10, e -&gt; {&#10;                if (isProducing) {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                } else {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            timer.start();&#10;        }&#10;        private int getBufferItemIndex(String item) {&#10;            int idx = 0;&#10;            for (String s : buffer) {&#10;                if (s.equals(item)) return idx;&#10;                idx++;&#10;            }&#10;            return 0;&#10;        }&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // 畫三個區塊&#10;            g.setColor(Color.LIGHT_GRAY);&#10;            g.fillRect(20, 100, 80, 80); // 生產者&#10;            g.fillRect(300, 100, 260, 80); // buffer&#10;            g.fillRect(580, 100, 80, 80); // 消費者&#10;            g.setColor(Color.BLACK);&#10;            g.drawRect(20, 100, 80, 80);&#10;            g.drawRect(300, 100, 260, 80);&#10;            g.drawRect(580, 100, 80, 80);&#10;            g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, 16));&#10;            g.drawString(&quot;生產者&quot;, 30, 95);&#10;            g.drawString(&quot;Buffer&quot;, 390, 95);&#10;            g.drawString(&quot;消費者&quot;, 590, 95);&#10;            // 畫箭頭&#10;            g.drawLine(100, 140, 300, 140);&#10;            g.drawLine(560, 140, 580, 140);&#10;            // 畫 buffer 內所有物品（以圓形+編號顯示）&#10;            int i = 0;&#10;            for (String item : buffer) {&#10;                int x = 320 + i * 60;&#10;                int y = 120;&#10;                g.setColor(Color.CYAN);&#10;                g.fillOval(x, y, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(x, y, 40, 40);&#10;                String num = getItemNumber(item);&#10;                g.drawString(num, x + 10, y + 25);&#10;                i++;&#10;            }&#10;            // 畫動畫物品&#10;            if (animatingItem != null) {&#10;                g.setColor(isProducing ? Color.YELLOW : Color.PINK);&#10;                g.fillOval(animX, animY, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(animX, animY, 40, 40);&#10;                String num = getItemNumber(animatingItem);&#10;                g.drawString(num, animX + 10, animY + 25);&#10;            }&#10;        }&#10;        private String getItemNumber(String item) {&#10;            int idx = item.lastIndexOf(&quot;:&quot;);&#10;            if (idx != -1 &amp;&amp; idx + 1 &lt; item.length()) {&#10;                return item.substring(idx + 1).trim();&#10;            }&#10;            return &quot;?&quot;;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Random;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class ProducerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JTextArea logArea;&#10;    private JPanel bufferPanel;&#10;    private ArrayBlockingQueue&lt;String&gt; buffer;&#10;    private ProducerThread producerThread;&#10;    private ConsumerThread consumerThread;&#10;    private FlowAnimationPanel animationPanel;&#10;&#10;    public ProducerGUI() {&#10;        setTitle(&quot;生產者範例&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(900, 500); // 預設較大視窗&#10;        setMinimumSize(new Dimension(900, 500));&#10;        setLayout(new BorderLayout());&#10;&#10;        // 使用 GridBagLayout 讓上方元件不亂掉，並加大間距&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(10, 10, 10, 10);&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        gbc.anchor = GridBagConstraints.WEST;&#10;        topPanel.add(new JLabel(&quot;Buffer 大小: &quot;), gbc);&#10;        gbc.gridx = 1;&#10;        bufferSizeField = new JTextField(&quot;5&quot;, 8);&#10;        topPanel.add(bufferSizeField, gbc);&#10;        gbc.gridx = 2;&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        topPanel.add(startButton, gbc);&#10;        gbc.gridx = 3;&#10;        gbc.weightx = 1;&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        topPanel.add(Box.createHorizontalGlue(), gbc);&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // bufferPanel 放在上方，顯示 buffer 內容&#10;        bufferPanel = new JPanel();&#10;        bufferPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 15, 15));&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot;Buffer 內容 (數據顯示)&quot;));&#10;        bufferPanel.setPreferredSize(new Dimension(900, 70));&#10;        add(bufferPanel, BorderLayout.CENTER);&#10;&#10;        // logArea 放在右側，寬度限制&#10;        logArea = new JTextArea();&#10;        logArea.setEditable(false);&#10;        JScrollPane logScroll = new JScrollPane(logArea);&#10;        logScroll.setPreferredSize(new Dimension(250, 200));&#10;        add(logScroll, BorderLayout.EAST);&#10;&#10;        animationPanel = new FlowAnimationPanel();&#10;        animationPanel.setPreferredSize(new Dimension(700, 200)); // 放大動畫區域&#10;        add(animationPanel, BorderLayout.SOUTH);&#10;&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                int n;&#10;                try {&#10;                    n = Integer.parseInt(bufferSizeField.getText());&#10;                    if (n &lt;= 0) throw new NumberFormatException();&#10;                } catch (NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(ProducerGUI.this, &quot;請輸入正整數作為 buffer 大小&quot;);&#10;                    return;&#10;                }&#10;                buffer = new ArrayBlockingQueue&lt;&gt;(n);&#10;                logArea.setText(&quot;&quot;);&#10;                if (producerThread != null &amp;&amp; producerThread.isAlive()) {&#10;                    producerThread.interrupt();&#10;                }&#10;                if (consumerThread != null &amp;&amp; consumerThread.isAlive()) {&#10;                    consumerThread.interrupt();&#10;                }&#10;                producerThread = new ProducerThread();&#10;                consumerThread = new ConsumerThread();&#10;                producerThread.start();&#10;                consumerThread.start();&#10;                startButton.setEnabled(false);&#10;                bufferSizeField.setEnabled(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateBufferPanel(String highlightItem, boolean isProduced) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            bufferPanel.removeAll();&#10;            for (String item : buffer) {&#10;                JLabel label = new JLabel(item);&#10;                label.setOpaque(true);&#10;                label.setBorder(BorderFactory.createLineBorder(Color.GRAY));&#10;                if (item.equals(highlightItem)) {&#10;                    if (isProduced) {&#10;                        label.setBackground(Color.YELLOW);&#10;                    } else {&#10;                        label.setBackground(Color.PINK);&#10;                    }&#10;                } else {&#10;                    label.setBackground(Color.WHITE);&#10;                }&#10;                bufferPanel.add(label);&#10;            }&#10;            bufferPanel.revalidate();&#10;            bufferPanel.repaint();&#10;        });&#10;    }&#10;&#10;    private void animateProduce(String item) {&#10;        animationPanel.animateProduce(item);&#10;    }&#10;    private void animateConsume(String item) {&#10;        animationPanel.animateConsume(item);&#10;    }&#10;&#10;    private class ProducerThread extends Thread {&#10;        private final Random rand = new Random();&#10;        private final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                String item = sdf.format(new Date()) + &quot; 編號:&quot; + (rand.nextInt(900) + 100);&#10;                try {&#10;                    buffer.put(item); // 滿時會阻塞&#10;                    SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;生產: &quot; + item + &quot;\n&quot;));&#10;                    updateBufferPanel(item, true);&#10;                    animateProduce(item);&#10;                    Thread.sleep(200);&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                startButton.setEnabled(true);&#10;                bufferSizeField.setEnabled(true);&#10;            });&#10;        }&#10;    }&#10;&#10;    private class ConsumerThread extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                try {&#10;                    String minItem = null;&#10;                    int minNum = Integer.MAX_VALUE;&#10;                    // 找出最小編號物品&#10;                    synchronized (buffer) {&#10;                        for (String item : buffer) {&#10;                            int idx = item.lastIndexOf(&quot;:&quot;);&#10;                            if (idx != -1) {&#10;                                int num = Integer.parseInt(item.substring(idx + 1));&#10;                                if (num &lt; minNum) {&#10;                                    minNum = num;&#10;                                    minItem = item;&#10;                                }&#10;                            }&#10;                        }&#10;                        if (minItem != null) {&#10;                            buffer.remove(minItem);&#10;                        }&#10;                    }&#10;                    if (minItem != null) {&#10;                        String finalMinItem = minItem;&#10;                        SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;消費: &quot; + finalMinItem + &quot;\n&quot;));&#10;                        updateBufferPanel(finalMinItem, false);&#10;                        animateConsume(finalMinItem);&#10;                    }&#10;                    Thread.sleep(300); // 消費速度可調整&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new ProducerGUI().setVisible(true));&#10;    }&#10;&#10;    // 動畫面板類別&#10;    class FlowAnimationPanel extends JPanel {&#10;        private String animatingItem = null;&#10;        private int animX = 0;&#10;        private int animY = 120;&#10;        private int targetX = 0;&#10;        private boolean isProducing = true;&#10;        private Timer timer;&#10;&#10;        public FlowAnimationPanel() {&#10;            setBackground(Color.WHITE);&#10;        }&#10;&#10;        public void animateProduce(String item) {&#10;            animatingItem = item;&#10;            animX = 60; // 生產者區塊右側&#10;            animY = 120;&#10;            targetX = 320; // buffer 區塊左側&#10;            isProducing = true;&#10;            startAnimation();&#10;        }&#10;        public void animateConsume(String item) {&#10;            animatingItem = item;&#10;            animX = 320 + getBufferItemIndex(item) * 60; // buffer區塊內對應物品位置&#10;            animY = 120;&#10;            targetX = 600; // 消費者區塊左側&#10;            isProducing = false;&#10;            startAnimation();&#10;        }&#10;        private void startAnimation() {&#10;            if (timer != null &amp;&amp; timer.isRunning()) timer.stop();&#10;            timer = new Timer(10, e -&gt; {&#10;                if (isProducing) {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                } else {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            timer.start();&#10;        }&#10;        private int getBufferItemIndex(String item) {&#10;            int idx = 0;&#10;            for (String s : buffer) {&#10;                if (s.equals(item)) return idx;&#10;                idx++;&#10;            }&#10;            return 0;&#10;        }&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // 畫三個區塊&#10;            g.setColor(Color.LIGHT_GRAY);&#10;            g.fillRect(20, 100, 80, 80); // 生產者&#10;            g.fillRect(300, 100, 260, 80); // buffer&#10;            g.fillRect(580, 100, 80, 80); // 消費者&#10;            g.setColor(Color.BLACK);&#10;            g.drawRect(20, 100, 80, 80);&#10;            g.drawRect(300, 100, 260, 80);&#10;            g.drawRect(580, 100, 80, 80);&#10;            g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, 16));&#10;            g.drawString(&quot;生產者&quot;, 30, 95);&#10;            g.drawString(&quot;Buffer&quot;, 390, 95);&#10;            g.drawString(&quot;消費者&quot;, 590, 95);&#10;            // 畫箭頭&#10;            g.drawLine(100, 140, 300, 140);&#10;            g.drawLine(560, 140, 580, 140);&#10;            // 畫 buffer 內所有物品（以圓形+編號顯示）&#10;            int i = 0;&#10;            for (String item : buffer) {&#10;                int x = 320 + i * 60;&#10;                int y = 120;&#10;                g.setColor(Color.CYAN);&#10;                g.fillOval(x, y, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(x, y, 40, 40);&#10;                String num = getItemNumber(item);&#10;                g.drawString(num, x + 10, y + 25);&#10;                i++;&#10;            }&#10;            // 畫動畫物品&#10;            if (animatingItem != null) {&#10;                g.setColor(isProducing ? Color.YELLOW : Color.PINK);&#10;                g.fillOval(animX, animY, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(animX, animY, 40, 40);&#10;                String num = getItemNumber(animatingItem);&#10;                g.drawString(num, animX + 10, animY + 25);&#10;            }&#10;        }&#10;        private String getItemNumber(String item) {&#10;            int idx = item.lastIndexOf(&quot;:&quot;);&#10;            if (idx != -1 &amp;&amp; idx + 1 &lt; item.length()) {&#10;                return item.substring(idx + 1).trim();&#10;            }&#10;            return &quot;?&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/_20250805/GenerateButtonListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/_20250805/GenerateButtonListener.java" />
              <option name="originalContent" value="/**********************************&#10; * 對應課程: Chapter 7&#10; * CourseWork2: 圖形的應用&#10; **********************************/&#10;&#10;// 本檔案內容已合併至 GraphGenerator.java，請移除本檔案以消除警告。&#10;&#10;package _20250805;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class GraphGenerator extends JFrame {&#10;    private JTextField vertexField;&#10;    private JTextField edgeField;&#10;    private JButton generateButton;&#10;    private GraphPanel graphPanel;&#10;&#10;    public GraphGenerator() {&#10;        setTitle(&quot;圖形生成器 - Graph Generator&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // 創建控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.setBorder(BorderFactory.createTitledBorder(&quot;設定參數&quot;));&#10;&#10;        controlPanel.add(new JLabel(&quot;頂點數量:&quot;));&#10;        vertexField = new JTextField(&quot;5&quot;, 5);&#10;        controlPanel.add(vertexField);&#10;&#10;        controlPanel.add(new JLabel(&quot;邊數量:&quot;));&#10;        edgeField = new JTextField(&quot;7&quot;, 5);&#10;        controlPanel.add(edgeField);&#10;&#10;        generateButton = new JButton(&quot;開始畫圖&quot;);&#10;        generateButton.addActionListener(new GenerateButtonListener());&#10;        controlPanel.add(generateButton);&#10;&#10;        // 創建繪圖面板&#10;        graphPanel = new GraphPanel();&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(graphPanel, BorderLayout.CENTER);&#10;&#10;        setSize(800, 600);&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private class GenerateButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            try {&#10;                int vertexCount = Integer.parseInt(vertexField.getText());&#10;                int edgeCount = Integer.parseInt(edgeField.getText());&#10;&#10;                if (vertexCount &lt; 1) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;頂點數量必須至少為1&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                int maxEdges = vertexCount * (vertexCount - 1) / 2; // 完全圖的最大邊數&#10;                if (edgeCount &lt; 0 || edgeCount &gt; maxEdges) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;邊數量必須在0到&quot; + maxEdges + &quot;之間&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                graphPanel.generateGraph(vertexCount, edgeCount);&#10;&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                        &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private class GraphPanel extends JPanel {&#10;        private List&lt;Vertex&gt; vertices;&#10;        private List&lt;Edge&gt; edges;&#10;        private Random random;&#10;&#10;        public GraphPanel() {&#10;            setBackground(Color.WHITE);&#10;            setBorder(BorderFactory.createTitledBorder(&quot;圖形顯示區&quot;));&#10;            vertices = new ArrayList&lt;&gt;();&#10;            edges = new ArrayList&lt;&gt;();&#10;            random = new Random();&#10;        }&#10;&#10;        public void generateGraph(int vertexCount, int edgeCount) {&#10;            vertices.clear();&#10;            edges.clear();&#10;&#10;            // 生成頂點位置（圓形排列）&#10;            int centerX = getWidth() / 2;&#10;            int centerY = getHeight() / 2;&#10;            int radius = Math.min(centerX, centerY) - 80;&#10;&#10;            for (int i = 0; i &lt; vertexCount; i++) {&#10;                double angle = 2 * Math.PI * i / vertexCount;&#10;                int x = centerX + (int)(radius * Math.cos(angle));&#10;                int y = centerY + (int)(radius * Math.sin(angle));&#10;                vertices.add(new Vertex(i, x, y));&#10;            }&#10;&#10;            // 生成邊&#10;            Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;            int edgesAdded = 0;&#10;&#10;            while (edgesAdded &lt; edgeCount &amp;&amp; edgeSet.size() &lt; vertexCount * (vertexCount - 1) / 2) {&#10;                int from = random.nextInt(vertexCount);&#10;                int to = random.nextInt(vertexCount);&#10;&#10;                if (from != to) {&#10;                    String edgeKey = Math.min(from, to) + &quot;-&quot; + Math.max(from, to);&#10;                    if (!edgeSet.contains(edgeKey)) {&#10;                        edgeSet.add(edgeKey);&#10;                        edges.add(new Edge(vertices.get(from), vertices.get(to)));&#10;                        edgesAdded++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            repaint();&#10;        }&#10;&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            Graphics2D g2d = (Graphics2D) g;&#10;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;            if (vertices.isEmpty()) {&#10;                // 顯示提示文字&#10;                g2d.setColor(Color.GRAY);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;                String message = &quot;請設定頂點和邊的數量，然後點擊「開始畫圖」&quot;;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int x = (getWidth() - fm.stringWidth(message)) / 2;&#10;                int y = getHeight() / 2;&#10;                g2d.drawString(message, x, y);&#10;                return;&#10;            }&#10;&#10;            // 繪製邊&#10;            g2d.setColor(Color.BLUE);&#10;            g2d.setStroke(new BasicStroke(2));&#10;            for (Edge edge : edges) {&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;            }&#10;&#10;            // 繪製頂點&#10;            for (Vertex vertex : vertices) {&#10;                // 繪製頂點圓圈&#10;                g2d.setColor(Color.RED);&#10;                g2d.fillOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;                g2d.drawOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點標籤&#10;                g2d.setColor(Color.WHITE);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                String label = String.valueOf(vertex.id);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int labelX = vertex.x - fm.stringWidth(label) / 2;&#10;                int labelY = vertex.y + fm.getAscent() / 2;&#10;                g2d.drawString(label, labelX, labelY);&#10;            }&#10;&#10;            // 顯示統計信息&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;            g2d.drawString(&quot;頂點數量: &quot; + vertices.size(), 10, 20);&#10;            g2d.drawString(&quot;邊數量: &quot; + edges.size(), 10, 35);&#10;        }&#10;    }&#10;&#10;    private class Vertex {&#10;        int id;&#10;        int x, y;&#10;&#10;        public Vertex(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    private class Edge {&#10;        Vertex from, to;&#10;&#10;        public Edge(Vertex from, Vertex to) {&#10;            this.from = from;&#10;            this.to = to;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;&#10;            new GraphGenerator().setVisible(true);&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="/**********************************&#10; * 對應課程: Chapter 7&#10; * CourseWork2: 圖形的應用&#10; **********************************/&#10;&#10;// 本檔案內容已合併至 GraphGenerator.java，請移除本檔案以消除警告。&#10;// 此檔案不應包含 public class，請刪除全部內容。" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/_20250805/GraphGenerator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/_20250805/GraphGenerator.java" />
              <option name="originalContent" value="/***********************************&#10; * 對應課程: Chapter 7&#10; * CourseWork2: 圖論基本應用2(Claude)&#10; ***********************************/&#10;&#10;package _20250805;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class GraphGenerator extends JFrame {&#10;    private JTextField vertexField;&#10;    private JTextField edgeField;&#10;    private JButton generateButton;&#10;    private JButton mstButton; // 新增 MST 按鈕&#10;    private GraphPanel graphPanel;&#10;    private JTextArea vertexInfoArea;&#10;    private JTextArea edgeInfoArea;&#10;&#10;    public GraphGenerator() {&#10;        setTitle(&quot;圖形生成器 - Graph Generator with Cost&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // 創建控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.setBorder(BorderFactory.createTitledBorder(&quot;設定參數&quot;));&#10;&#10;        controlPanel.add(new JLabel(&quot;頂點數量:&quot;));&#10;        vertexField = new JTextField(&quot;5&quot;, 5);&#10;        controlPanel.add(vertexField);&#10;&#10;        controlPanel.add(new JLabel(&quot;邊數量:&quot;));&#10;        edgeField = new JTextField(&quot;7&quot;, 5);&#10;        controlPanel.add(edgeField);&#10;&#10;        generateButton = new JButton(&quot;開始畫圖&quot;);&#10;        generateButton.addActionListener(new GenerateButtonListener());&#10;        controlPanel.add(generateButton);&#10;&#10;        mstButton = new JButton(&quot;計算最小生成樹&quot;);&#10;        mstButton.addActionListener(new MSTButtonListener());&#10;        controlPanel.add(mstButton);&#10;&#10;        // 創建主要內容面板&#10;        JPanel mainPanel = new JPanel(new BorderLayout());&#10;&#10;        // 創建繪圖面板&#10;        graphPanel = new GraphPanel();&#10;        graphPanel.setPreferredSize(new Dimension(600, 500));&#10;&#10;        // 創建資訊顯示面板&#10;        JPanel infoPanel = new JPanel(new GridLayout(2, 1));&#10;        infoPanel.setPreferredSize(new Dimension(300, 500));&#10;&#10;        // 頂點資訊區域&#10;        JPanel vertexPanel = new JPanel(new BorderLayout());&#10;        vertexPanel.setBorder(BorderFactory.createTitledBorder(&quot;頂點資訊&quot;));&#10;        vertexInfoArea = new JTextArea();&#10;        vertexInfoArea.setEditable(false);&#10;        vertexInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane vertexScrollPane = new JScrollPane(vertexInfoArea);&#10;        vertexScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        vertexPanel.add(vertexScrollPane, BorderLayout.CENTER);&#10;&#10;        // 邊資訊區域&#10;        JPanel edgePanel = new JPanel(new BorderLayout());&#10;        edgePanel.setBorder(BorderFactory.createTitledBorder(&quot;邊資訊 (包含成本)&quot;));&#10;        edgeInfoArea = new JTextArea();&#10;        edgeInfoArea.setEditable(false);&#10;        edgeInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane edgeScrollPane = new JScrollPane(edgeInfoArea);&#10;        edgeScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        edgePanel.add(edgeScrollPane, BorderLayout.CENTER);&#10;&#10;        infoPanel.add(vertexPanel);&#10;        infoPanel.add(edgePanel);&#10;&#10;        mainPanel.add(graphPanel, BorderLayout.CENTER);&#10;        mainPanel.add(infoPanel, BorderLayout.EAST);&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(mainPanel, BorderLayout.CENTER);&#10;&#10;        setSize(950, 600);&#10;        setLocationRelativeTo(null);&#10;&#10;        // 初始化資訊顯示&#10;        updateInfoDisplay();&#10;    }&#10;&#10;    private class GenerateButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            try {&#10;                int vertexCount = Integer.parseInt(vertexField.getText());&#10;                int edgeCount = Integer.parseInt(edgeField.getText());&#10;&#10;                if (vertexCount &lt; 1) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;頂點數量必須至少為1&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                int maxEdges = vertexCount * (vertexCount - 1) / 2; // 完全圖的最大邊數&#10;                if (edgeCount &lt; 0 || edgeCount &gt; maxEdges) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;邊數量必須在0到&quot; + maxEdges + &quot;之間&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                graphPanel.generateGraph(vertexCount, edgeCount);&#10;                updateInfoDisplay();&#10;&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                        &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private class MSTButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            mstEdges = calculateMST(graphPanel.getVertices(), graphPanel.getEdges());&#10;            updateInfoDisplay();&#10;            graphPanel.repaint();&#10;        }&#10;    }&#10;&#10;    private List&lt;Edge&gt; mstEdges = new ArrayList&lt;&gt;(); // MST 邊&#10;&#10;    private void updateInfoDisplay() {&#10;        // 更新頂點資訊&#10;        StringBuilder vertexInfo = new StringBuilder();&#10;        List&lt;Vertex&gt; vertices = graphPanel.getVertices();&#10;&#10;        if (vertices.isEmpty()) {&#10;            vertexInfo.append(&quot;尚未生成圖形\n&quot;);&#10;            vertexInfo.append(&quot;請設定參數後點擊「開始畫圖」&quot;);&#10;        } else {&#10;            vertexInfo.append(&quot;頂點總數: &quot;).append(vertices.size()).append(&quot;\n\n&quot;);&#10;            vertexInfo.append(&quot;頂點列表:\n&quot;);&#10;            vertexInfo.append(&quot;ID  座標(X, Y)\n&quot;);&#10;            vertexInfo.append(&quot;================\n&quot;);&#10;            for (Vertex vertex : vertices) {&#10;                vertexInfo.append(String.format(&quot;V%-2d (%3d, %3d)\n&quot;,&#10;                        vertex.id, vertex.x, vertex.y));&#10;            }&#10;        }&#10;        vertexInfoArea.setText(vertexInfo.toString());&#10;&#10;        // 更新邊資訊&#10;        StringBuilder edgeInfo = new StringBuilder();&#10;        List&lt;Edge&gt; edges = graphPanel.getEdges();&#10;&#10;        if (edges.isEmpty() &amp;&amp; !vertices.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: 0\n\n&quot;);&#10;            edgeInfo.append(&quot;無邊連接&quot;);&#10;        } else if (!edges.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: &quot;).append(edges.size()).append(&quot;\n\n&quot;);&#10;            edgeInfo.append(&quot;邊列表 (雙向):\n&quot;);&#10;            edgeInfo.append(&quot;邊      成本\n&quot;);&#10;            edgeInfo.append(&quot;================\n&quot;);&#10;            for (Edge edge : edges) {&#10;                edgeInfo.append(String.format(&quot;V%d-V%d   %2d\n&quot;,&#10;                        edge.from.id, edge.to.id, edge.cost));&#10;            }&#10;&#10;            // 計算總成本&#10;            int totalCost = edges.stream().mapToInt(edge -&gt; edge.cost).sum();&#10;            edgeInfo.append(&quot;\n總成本: &quot;).append(totalCost);&#10;        } else {&#10;            edgeInfo.append(&quot;尚未生成圖形&quot;);&#10;        }&#10;&#10;        // 更新 MST 邊資訊&#10;        if (!mstEdges.isEmpty()) {&#10;            edgeInfo.append(&quot;\n最小生成樹 MST 邊數: &quot;).append(mstEdges.size()).append(&quot;\n&quot;);&#10;            int mstCost = mstEdges.stream().mapToInt(e -&gt; e.cost).sum();&#10;            edgeInfo.append(&quot;MST 總成本: &quot;).append(mstCost).append(&quot;\n&quot;);&#10;            edgeInfo.append(&quot;MST 邊列表:\n&quot;);&#10;            for (Edge edge : mstEdges) {&#10;                edgeInfo.append(String.format(&quot;V%d-V%d   %2d\n&quot;, edge.from.id, edge.to.id, edge.cost));&#10;            }&#10;        }&#10;&#10;        edgeInfoArea.setText(edgeInfo.toString());&#10;    }&#10;&#10;    // Kruskal 演算法計算 MST&#10;    private List&lt;Edge&gt; calculateMST(List&lt;Vertex&gt; vertices, List&lt;Edge&gt; edges) {&#10;        List&lt;Edge&gt; result = new ArrayList&lt;&gt;();&#10;        if (vertices.isEmpty() || edges.isEmpty()) return result;&#10;        int n = vertices.size();&#10;        int[] parent = new int[n];&#10;        for (int i = 0; i &lt; n; i++) parent[i] = i;&#10;        edges.sort(Comparator.comparingInt(e -&gt; e.cost));&#10;        int count = 0;&#10;        for (Edge edge : edges) {&#10;            int a = find(parent, edge.from.id);&#10;            int b = find(parent, edge.to.id);&#10;            if (a != b) {&#10;                result.add(edge);&#10;                parent[a] = b;&#10;                count++;&#10;                if (count == n - 1) break;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;    private int find(int[] parent, int x) {&#10;        if (parent[x] != x) parent[x] = find(parent, parent[x]);&#10;        return parent[x];&#10;    }&#10;&#10;    private class GraphPanel extends JPanel {&#10;        private List&lt;Vertex&gt; vertices;&#10;        private List&lt;Edge&gt; edges;&#10;        private Random random;&#10;&#10;        public GraphPanel() {&#10;            setBackground(Color.WHITE);&#10;            setBorder(BorderFactory.createTitledBorder(&quot;圖形顯示區&quot;));&#10;            vertices = new ArrayList&lt;&gt;();&#10;            edges = new ArrayList&lt;&gt;();&#10;            random = new Random();&#10;        }&#10;&#10;        public List&lt;Vertex&gt; getVertices() {&#10;            return new ArrayList&lt;&gt;(vertices);&#10;        }&#10;&#10;        public List&lt;Edge&gt; getEdges() {&#10;            return new ArrayList&lt;&gt;(edges);&#10;        }&#10;&#10;        public void generateGraph(int vertexCount, int edgeCount) {&#10;            vertices.clear();&#10;            edges.clear();&#10;&#10;            // 生成頂點位置（圓形排列）&#10;            int centerX = getWidth() / 2;&#10;            int centerY = getHeight() / 2;&#10;            int radius = Math.min(centerX, centerY) - 100;&#10;&#10;            for (int i = 0; i &lt; vertexCount; i++) {&#10;                double angle = 2 * Math.PI * i / vertexCount;&#10;                int x = centerX + (int)(radius * Math.cos(angle));&#10;                int y = centerY + (int)(radius * Math.sin(angle));&#10;                vertices.add(new Vertex(i, x, y));&#10;            }&#10;&#10;            // 生成無向邊（雙向但只建立一次）&#10;            Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;            int edgesAdded = 0;&#10;&#10;            while (edgesAdded &lt; edgeCount &amp;&amp; edgeSet.size() &lt; vertexCount * (vertexCount - 1) / 2) {&#10;                int from = random.nextInt(vertexCount);&#10;                int to = random.nextInt(vertexCount);&#10;&#10;                if (from != to) {&#10;                    // 確保較小的ID在前面，避免重複邊&#10;                    int minId = Math.min(from, to);&#10;                    int maxId = Math.max(from, to);&#10;                    String edgeKey = minId + &quot;-&quot; + maxId;&#10;&#10;                    if (!edgeSet.contains(edgeKey)) {&#10;                        edgeSet.add(edgeKey);&#10;                        int cost = random.nextInt(99) + 1; // 1-99之間的隨機成本&#10;                        edges.add(new Edge(vertices.get(minId), vertices.get(maxId), cost));&#10;                        edgesAdded++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            repaint();&#10;        }&#10;&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            Graphics2D g2d = (Graphics2D) g;&#10;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;            if (vertices.isEmpty()) {&#10;                // 顯示提示文字&#10;                g2d.setColor(Color.GRAY);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 18));&#10;                String message = &quot;請設定頂點和邊的數量&quot;;&#10;                String message2 = &quot;然後點擊「開始畫圖」&quot;;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int x1 = (getWidth() - fm.stringWidth(message)) / 2;&#10;                int x2 = (getWidth() - fm.stringWidth(message2)) / 2;&#10;                int y = getHeight() / 2 - 15;&#10;                g2d.drawString(message, x1, y);&#10;                g2d.drawString(message2, x2, y + 30);&#10;                return;&#10;            }&#10;&#10;            // 先畫 MST 邊（用橘色高亮）&#10;            g2d.setColor(Color.ORANGE);&#10;            g2d.setStroke(new BasicStroke(4));&#10;            for (Edge edge : mstEdges) {&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;                // 在邊中點顯示橘色成本文字&#10;                int midX = (edge.from.x + edge.to.x) / 2;&#10;                int midY = (edge.from.y + edge.to.y) / 2;&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                g2d.setColor(Color.ORANGE);&#10;                String costText = String.valueOf(edge.cost);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int textX = midX - fm.stringWidth(costText) / 2;&#10;                int textY = midY - 10;&#10;                g2d.drawString(costText, textX, textY);&#10;                g2d.setColor(Color.ORANGE);&#10;            }&#10;&#10;            // 繪製邊和成本標籤&#10;            g2d.setColor(Color.BLUE);&#10;            g2d.setStroke(new BasicStroke(2));&#10;            for (Edge edge : edges) {&#10;                // 繪製邊&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;&#10;                // 計算邊的中點位置&#10;                int midX = (edge.from.x + edge.to.x) / 2;&#10;                int midY = (edge.from.y + edge.to.y) / 2;&#10;&#10;                // 繪製成本標籤背景&#10;                g2d.setColor(Color.YELLOW);&#10;                g2d.fillRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本標籤邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(1));&#10;                g2d.drawRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本數字&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;                String costText = String.valueOf(edge.cost);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int textX = midX - fm.stringWidth(costText) / 2;&#10;                int textY = midY + fm.getAscent() / 2;&#10;                g2d.drawString(costText, textX, textY);&#10;&#10;                // 重設顏色和筆觸以繪製下一條邊&#10;                g2d.setColor(Color.BLUE);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;&#10;            // 繪製頂點&#10;            for (Vertex vertex : vertices) {&#10;                // 繪製頂點圓圈&#10;                g2d.setColor(Color.RED);&#10;                g2d.fillOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;                g2d.drawOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點標籤&#10;                g2d.setColor(Color.WHITE);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                String label = &quot;V&quot; + vertex.id;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int labelX = vertex.x - fm.stringWidth(label) / 2;&#10;                int labelY = vertex.y + fm.getAscent() / 2;&#10;                g2d.drawString(label, labelX, labelY);&#10;            }&#10;&#10;            // 顯示統計信息（放在右上角避免重疊）&#10;            // 已取消頂點/邊/總成本文字顯示&#10;        }&#10;    }&#10;&#10;    private class Vertex {&#10;        int id;&#10;        int x, y;&#10;&#10;        public Vertex(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    private class Edge {&#10;        Vertex from, to;&#10;        int cost;&#10;&#10;        public Edge(Vertex from, Vertex to, int cost) {&#10;            this.from = from;&#10;            this.to = to;&#10;            this.cost = cost;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;&#10;            new GraphGenerator().setVisible(true);&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="/***********************************&#10; * 對應課程: Chapter 7&#10; * CourseWork2: 圖論基本應用2(Claude)&#10; ***********************************/&#10;&#10;package _20250805;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class GraphGenerator extends JFrame {&#10;    private JTextField vertexField;&#10;    private JTextField edgeField;&#10;    private JButton generateButton;&#10;    private JButton mstButton; // 新增 MST 按鈕&#10;    private GraphPanel graphPanel;&#10;    private JTextArea vertexInfoArea;&#10;    private JTextArea edgeInfoArea;&#10;&#10;    public GraphGenerator() {&#10;        setTitle(&quot;圖形生成器 - Graph Generator with Cost&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // 創建控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.setBorder(BorderFactory.createTitledBorder(&quot;設定參數&quot;));&#10;&#10;        controlPanel.add(new JLabel(&quot;頂點數量:&quot;));&#10;        vertexField = new JTextField(&quot;5&quot;, 5);&#10;        controlPanel.add(vertexField);&#10;&#10;        controlPanel.add(new JLabel(&quot;邊數量:&quot;));&#10;        edgeField = new JTextField(&quot;7&quot;, 5);&#10;        controlPanel.add(edgeField);&#10;&#10;        generateButton = new JButton(&quot;開始畫圖&quot;);&#10;        generateButton.addActionListener(new GenerateButtonListener());&#10;        controlPanel.add(generateButton);&#10;&#10;        mstButton = new JButton(&quot;計算最小生成樹&quot;);&#10;        mstButton.addActionListener(new MSTButtonListener());&#10;        controlPanel.add(mstButton);&#10;&#10;        // 創建主要內容面板&#10;        JPanel mainPanel = new JPanel(new BorderLayout());&#10;&#10;        // 創建繪圖面板&#10;        graphPanel = new GraphPanel();&#10;        graphPanel.setPreferredSize(new Dimension(600, 500));&#10;&#10;        // 創建資訊顯示面板&#10;        JPanel infoPanel = new JPanel(new GridLayout(2, 1));&#10;        infoPanel.setPreferredSize(new Dimension(300, 500));&#10;&#10;        // 頂點資訊區域&#10;        JPanel vertexPanel = new JPanel(new BorderLayout());&#10;        vertexPanel.setBorder(BorderFactory.createTitledBorder(&quot;頂點資訊&quot;));&#10;        vertexInfoArea = new JTextArea();&#10;        vertexInfoArea.setEditable(false);&#10;        vertexInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane vertexScrollPane = new JScrollPane(vertexInfoArea);&#10;        vertexScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        vertexPanel.add(vertexScrollPane, BorderLayout.CENTER);&#10;&#10;        // 邊資訊區域&#10;        JPanel edgePanel = new JPanel(new BorderLayout());&#10;        edgePanel.setBorder(BorderFactory.createTitledBorder(&quot;邊資訊 (包含成本)&quot;));&#10;        edgeInfoArea = new JTextArea();&#10;        edgeInfoArea.setEditable(false);&#10;        edgeInfoArea.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));&#10;        JScrollPane edgeScrollPane = new JScrollPane(edgeInfoArea);&#10;        edgeScrollPane.setPreferredSize(new Dimension(290, 230));&#10;        edgePanel.add(edgeScrollPane, BorderLayout.CENTER);&#10;&#10;        infoPanel.add(vertexPanel);&#10;        infoPanel.add(edgePanel);&#10;&#10;        mainPanel.add(graphPanel, BorderLayout.CENTER);&#10;        mainPanel.add(infoPanel, BorderLayout.EAST);&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(mainPanel, BorderLayout.CENTER);&#10;&#10;        setSize(950, 600);&#10;        setLocationRelativeTo(null);&#10;&#10;        // 初始化資訊顯示&#10;        updateInfoDisplay();&#10;    }&#10;&#10;    private class GenerateButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            try {&#10;                int vertexCount = Integer.parseInt(vertexField.getText());&#10;                int edgeCount = Integer.parseInt(edgeField.getText());&#10;&#10;                if (vertexCount &lt; 1) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;頂點數量必須至少為1&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                int maxEdges = vertexCount * (vertexCount - 1) / 2; // 完全圖的最大邊數&#10;                if (edgeCount &lt; 0 || edgeCount &gt; maxEdges) {&#10;                    JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                            &quot;邊數量必須在0到&quot; + maxEdges + &quot;之間&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    return;&#10;                }&#10;&#10;                graphPanel.generateGraph(vertexCount, edgeCount);&#10;                updateInfoDisplay();&#10;&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(GraphGenerator.this,&#10;                        &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private class MSTButtonListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            mstEdges = calculateMST(graphPanel.getVertices(), graphPanel.getEdges());&#10;            updateInfoDisplay();&#10;            graphPanel.repaint();&#10;        }&#10;    }&#10;&#10;    private List&lt;Edge&gt; mstEdges = new ArrayList&lt;&gt;(); // MST 邊&#10;&#10;    private void updateInfoDisplay() {&#10;        // 更新頂點資訊&#10;        StringBuilder vertexInfo = new StringBuilder();&#10;        List&lt;Vertex&gt; vertices = graphPanel.getVertices();&#10;&#10;        if (vertices.isEmpty()) {&#10;            vertexInfo.append(&quot;尚未生成圖形\n&quot;);&#10;            vertexInfo.append(&quot;請設定參數後點擊「開始畫圖」&quot;);&#10;        } else {&#10;            vertexInfo.append(&quot;頂點總數: &quot;).append(vertices.size()).append(&quot;\n\n&quot;);&#10;            vertexInfo.append(&quot;頂點列表:\n&quot;);&#10;            vertexInfo.append(&quot;ID  座標(X, Y)\n&quot;);&#10;            vertexInfo.append(&quot;================\n&quot;);&#10;            for (Vertex vertex : vertices) {&#10;                vertexInfo.append(String.format(&quot;V%-2d (%3d, %3d)\n&quot;,&#10;                        vertex.id, vertex.x, vertex.y));&#10;            }&#10;        }&#10;        vertexInfoArea.setText(vertexInfo.toString());&#10;&#10;        // 更新邊資訊&#10;        StringBuilder edgeInfo = new StringBuilder();&#10;        List&lt;Edge&gt; edges = graphPanel.getEdges();&#10;&#10;        if (edges.isEmpty() &amp;&amp; !vertices.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: 0\n\n&quot;);&#10;            edgeInfo.append(&quot;無邊連接&quot;);&#10;        } else if (!edges.isEmpty()) {&#10;            edgeInfo.append(&quot;邊總數: &quot;).append(edges.size()).append(&quot;\n\n&quot;);&#10;            edgeInfo.append(&quot;邊列表 (雙向):\n&quot;);&#10;            edgeInfo.append(&quot;邊      成本\n&quot;);&#10;            edgeInfo.append(&quot;================\n&quot;);&#10;            for (Edge edge : edges) {&#10;                edgeInfo.append(String.format(&quot;V%d-V%d   %2d\n&quot;,&#10;                        edge.from.id, edge.to.id, edge.cost));&#10;            }&#10;&#10;            // 計算總成本&#10;            int totalCost = edges.stream().mapToInt(edge -&gt; edge.cost).sum();&#10;            edgeInfo.append(&quot;\n總成本: &quot;).append(totalCost);&#10;        } else {&#10;            edgeInfo.append(&quot;尚未生成圖形&quot;);&#10;        }&#10;&#10;        // 更新 MST 邊資訊&#10;        if (!mstEdges.isEmpty()) {&#10;            edgeInfo.append(&quot;\n最小生成樹 MST 邊數: &quot;).append(mstEdges.size()).append(&quot;\n&quot;);&#10;            int mstCost = mstEdges.stream().mapToInt(e -&gt; e.cost).sum();&#10;            edgeInfo.append(&quot;MST 總成本: &quot;).append(mstCost).append(&quot;\n&quot;);&#10;            edgeInfo.append(&quot;MST 邊列表:\n&quot;);&#10;            for (Edge edge : mstEdges) {&#10;                edgeInfo.append(String.format(&quot;V%d-V%d   %2d\n&quot;, edge.from.id, edge.to.id, edge.cost));&#10;            }&#10;        }&#10;&#10;        edgeInfoArea.setText(edgeInfo.toString());&#10;        // 如果有 MST 結果，設置橘色文字&#10;        if (!mstEdges.isEmpty()) {&#10;            edgeInfoArea.setForeground(new Color(255, 140, 0)); // 橘色&#10;        } else {&#10;            edgeInfoArea.setForeground(Color.BLACK);&#10;        }&#10;    }&#10;&#10;    // Kruskal 演算法計算 MST&#10;    private List&lt;Edge&gt; calculateMST(List&lt;Vertex&gt; vertices, List&lt;Edge&gt; edges) {&#10;        List&lt;Edge&gt; result = new ArrayList&lt;&gt;();&#10;        if (vertices.isEmpty() || edges.isEmpty()) return result;&#10;        int n = vertices.size();&#10;        int[] parent = new int[n];&#10;        for (int i = 0; i &lt; n; i++) parent[i] = i;&#10;        edges.sort(Comparator.comparingInt(e -&gt; e.cost));&#10;        int count = 0;&#10;        for (Edge edge : edges) {&#10;            int a = find(parent, edge.from.id);&#10;            int b = find(parent, edge.to.id);&#10;            if (a != b) {&#10;                result.add(edge);&#10;                parent[a] = b;&#10;                count++;&#10;                if (count == n - 1) break;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;    private int find(int[] parent, int x) {&#10;        if (parent[x] != x) parent[x] = find(parent, parent[x]);&#10;        return parent[x];&#10;    }&#10;&#10;    private class GraphPanel extends JPanel {&#10;        private List&lt;Vertex&gt; vertices;&#10;        private List&lt;Edge&gt; edges;&#10;        private Random random;&#10;&#10;        public GraphPanel() {&#10;            setBackground(Color.WHITE);&#10;            setBorder(BorderFactory.createTitledBorder(&quot;圖形顯示區&quot;));&#10;            vertices = new ArrayList&lt;&gt;();&#10;            edges = new ArrayList&lt;&gt;();&#10;            random = new Random();&#10;        }&#10;&#10;        public List&lt;Vertex&gt; getVertices() {&#10;            return new ArrayList&lt;&gt;(vertices);&#10;        }&#10;&#10;        public List&lt;Edge&gt; getEdges() {&#10;            return new ArrayList&lt;&gt;(edges);&#10;        }&#10;&#10;        public void generateGraph(int vertexCount, int edgeCount) {&#10;            vertices.clear();&#10;            edges.clear();&#10;&#10;            // 生成頂點位置（圓形排列）&#10;            int centerX = getWidth() / 2;&#10;            int centerY = getHeight() / 2;&#10;            int radius = Math.min(centerX, centerY) - 100;&#10;&#10;            for (int i = 0; i &lt; vertexCount; i++) {&#10;                double angle = 2 * Math.PI * i / vertexCount;&#10;                int x = centerX + (int)(radius * Math.cos(angle));&#10;                int y = centerY + (int)(radius * Math.sin(angle));&#10;                vertices.add(new Vertex(i, x, y));&#10;            }&#10;&#10;            // 生成無向邊（雙向但只建立一次）&#10;            Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;            int edgesAdded = 0;&#10;&#10;            while (edgesAdded &lt; edgeCount &amp;&amp; edgeSet.size() &lt; vertexCount * (vertexCount - 1) / 2) {&#10;                int from = random.nextInt(vertexCount);&#10;                int to = random.nextInt(vertexCount);&#10;&#10;                if (from != to) {&#10;                    // 確保較小的ID在前面，避免重複邊&#10;                    int minId = Math.min(from, to);&#10;                    int maxId = Math.max(from, to);&#10;                    String edgeKey = minId + &quot;-&quot; + maxId;&#10;&#10;                    if (!edgeSet.contains(edgeKey)) {&#10;                        edgeSet.add(edgeKey);&#10;                        int cost = random.nextInt(99) + 1; // 1-99之間的隨機成本&#10;                        edges.add(new Edge(vertices.get(minId), vertices.get(maxId), cost));&#10;                        edgesAdded++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            repaint();&#10;        }&#10;&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            Graphics2D g2d = (Graphics2D) g;&#10;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;            if (vertices.isEmpty()) {&#10;                // 顯示提示文字&#10;                g2d.setColor(Color.GRAY);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 18));&#10;                String message = &quot;請設定頂點和邊的數量&quot;;&#10;                String message2 = &quot;然後點擊「開始畫圖」&quot;;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int x1 = (getWidth() - fm.stringWidth(message)) / 2;&#10;                int x2 = (getWidth() - fm.stringWidth(message2)) / 2;&#10;                int y = getHeight() / 2 - 15;&#10;                g2d.drawString(message, x1, y);&#10;                g2d.drawString(message2, x2, y + 30);&#10;                return;&#10;            }&#10;&#10;            // 先畫 MST 邊（用橘色高亮）&#10;            g2d.setColor(Color.ORANGE);&#10;            g2d.setStroke(new BasicStroke(4));&#10;            for (Edge edge : mstEdges) {&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;                // 在邊中點顯示橘色成本文字&#10;                int midX = (edge.from.x + edge.to.x) / 2;&#10;                int midY = (edge.from.y + edge.to.y) / 2;&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                g2d.setColor(Color.ORANGE);&#10;                String costText = String.valueOf(edge.cost);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int textX = midX - fm.stringWidth(costText) / 2;&#10;                int textY = midY - 10;&#10;                g2d.drawString(costText, textX, textY);&#10;                g2d.setColor(Color.ORANGE);&#10;            }&#10;&#10;            // 繪製邊和成本標籤&#10;            g2d.setColor(Color.BLUE);&#10;            g2d.setStroke(new BasicStroke(2));&#10;            for (Edge edge : edges) {&#10;                // 繪製邊&#10;                g2d.drawLine(edge.from.x, edge.from.y, edge.to.x, edge.to.y);&#10;&#10;                // 計算邊的中點位置&#10;                int midX = (edge.from.x + edge.to.x) / 2;&#10;                int midY = (edge.from.y + edge.to.y) / 2;&#10;&#10;                // 繪製成本標籤背景&#10;                g2d.setColor(Color.YELLOW);&#10;                g2d.fillRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本標籤邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(1));&#10;                g2d.drawRoundRect(midX - 12, midY - 8, 24, 16, 6, 6);&#10;&#10;                // 繪製成本數字&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;                String costText = String.valueOf(edge.cost);&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int textX = midX - fm.stringWidth(costText) / 2;&#10;                int textY = midY + fm.getAscent() / 2;&#10;                g2d.drawString(costText, textX, textY);&#10;&#10;                // 重設顏色和筆觸以繪製下一條邊&#10;                g2d.setColor(Color.BLUE);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;&#10;            // 繪製頂點&#10;            for (Vertex vertex : vertices) {&#10;                // 繪製頂點圓圈&#10;                g2d.setColor(Color.RED);&#10;                g2d.fillOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點邊框&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;                g2d.drawOval(vertex.x - 15, vertex.y - 15, 30, 30);&#10;&#10;                // 繪製頂點標籤&#10;                g2d.setColor(Color.WHITE);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;                String label = &quot;V&quot; + vertex.id;&#10;                FontMetrics fm = g2d.getFontMetrics();&#10;                int labelX = vertex.x - fm.stringWidth(label) / 2;&#10;                int labelY = vertex.y + fm.getAscent() / 2;&#10;                g2d.drawString(label, labelX, labelY);&#10;            }&#10;&#10;            // 顯示統計信息（放在右上角避免重疊）&#10;            // 已取消頂點/邊/總成本文字顯示&#10;        }&#10;    }&#10;&#10;    private class Vertex {&#10;        int id;&#10;        int x, y;&#10;&#10;        public Vertex(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    private class Edge {&#10;        Vertex from, to;&#10;        int cost;&#10;&#10;        public Edge(Vertex from, Vertex to, int cost) {&#10;            this.from = from;&#10;            this.to = to;&#10;            this.cost = cost;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;&#10;            new GraphGenerator().setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>