<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# FCU Data Structures And Algorithms&#10;&#10;本專案為逢甲大學資料結構與演算法課程相關的 Java 練習與作業彙整。&#10;&#10;## 課程內容&#10;&#10;- 第1章 資料結構導論（Introduction）&#10;- 第2章 陣列與矩陣（Arrays and Matrices）&#10;- 第3章 鏈結串列（Linked Lists）&#10;- 第4章 堆疊（Stacks）&#10;- 第5章 佇列（Queues）&#10;- 第6章 樹與二元樹（Trees and Binary Trees）&#10;- 第7章 圖形結構（Graphs）&#10;- 第8章 資料排序（Sorting）&#10;- 第9章 資料搜尋（Searching）&#10;&#10;## 專案結構&#10;&#10;- `src/`：所有 Java 原始碼、HTML、CSS、JS 檔案&#10;    - `_20250701/`&#10;        - `GCDLCMCalculator.java`：最大公因數/最小公倍數計算器&#10;        - `ImageViewer.java`：網頁介面簡易圖片瀏覽器&#10;        - `index.html`、`index2.html`、`pomodoro.html`：網頁介面番茄鐘工具&#10;        - `script.js`、`style.css`：網頁腳本與樣式&#10;    - `_20250708/`&#10;        - `MatrixSearchDemo.java`：矩陣搜尋演算法比較&#10;    - `_20250714/`&#10;        - `FactorialComparison.java`：階乘運算效率比較（for迴圈）&#10;        - `FactorialComparison2.java`：階乘運算效率比較（遞迴）&#10;    - `_20250715/`&#10;        - `SparseMatrixGUI.java`：稀疏矩陣操作與顯示&#10;        - `Timetable.java`：課表管理工具&#10;    - `_20250723/`&#10;        - `MusicPlayer.java`：簡易音樂播放器（命令列）&#10;        - `MusicPlayerGUI.java`：簡易音樂播放器（圖形介面）&#10;    - `_20250724/`&#10;        - `InfixConverterGUI.java`：中序轉後序運算式工具&#10;        - `SimplePaint.java`：簡易小畫家1&#10;        - `DrawingApp.java`：簡易小畫家2&#10;    - `_20250728/`&#10;        - `RestaurantSimulation.java` ~ `RestaurantSimulation7.java`：餐廳點餐、排隊、出餐等流程模擬（多版本）&#10;    - `_20250729/`&#10;        - `ArrayBinaryTreeGUI.java`：陣列實作二元樹操作&#10;        - `ProducerGUI.java`：生產者消費者問題模擬&#10;    - `_20250805/`&#10;        - `GraphDemoGUI.java`：圖形結構操作與展示（圖形介面）&#10;        - `GraphGenerator.java`：圖形結構產生器&#10;        - `GraphGUI.java`：圖形結構互動介面&#10;    - `_20250811/`&#10;        - `ArticulationPointComparison.java`：關節點（割點）演算法效能比較&#10;        - `articulation_point_result.csv`：關節點演算法效能比較結果（CSV）&#10;        - `關節點演算法效能比較.pptx`：關節點演算法效能比較ppt&#10;    - `_20250812/`&#10;        - `GraphGeneratorGUI.java`：圖形結構產生器（圖形介面）最短路徑。Dijkstra 演算法、Floyd-Warshall 演算法&#10;    - `_20250818/`&#10;        - `StockDataGenerator.java`：隨機股票資料產生器&#10;        - `StockRankingGUI.java`：股票漲跌幅排行圖形介面&#10;        - `stock_data.csv`：範例股票資料（CSV）&#10;    - `_20250828/`&#10;        - `coursework1/`&#10;            - `ItemTransactionDataGenerator.java`：隨機產生大量物品交易資料（含交易代碼、日期、客戶代碼、物品名稱、價格）&#10;            - `item_transactions.csv`：由程式產生的範例交易資料（CSV 格式）&#10;            - `SearchPerformanceComparison.java`：線性搜尋、二分搜尋、插補搜尋、雜湊搜尋等方法效能比較（含 GUI 與統計分析）&#10;        - `coursework2/`&#10;            - `TradeRecord.java`：單筆交易資料類別&#10;            - `TradeDataManager.java`：股票逐筆交易資料的載入、管理與查詢&#10;            - `TradeDataGUI.java`：股票逐筆交易資料的圖形化查詢介面&#10;            - `2317-Minute-Trade.csv`、`2330-Minute-Trade.csv`、`2382-Minute-Trade.csv`：三檔股票逐筆交易資料（CSV 格式）&#10;            - `prompt.md`：作業說明文件&#10;          &#10;- 主要功能包含：&#10;    - 演算法比較（如矩陣搜尋、階乘運算）&#10;    - 資料結構操作（如二元樹、稀疏矩陣）&#10;    - GUI 應用（如音樂播放器、餐廳模擬、繪圖工具）&#10;    - 其他課堂練習&#10;&#10;## 執行方式&#10;&#10;1. 使用 IntelliJ IDEA 或其他支援 Java 的 IDE 開啟本專案。&#10;2. 進入 `src/` 目錄，選擇欲執行的 Java 檔案，執行主方法（`main`）。&#10;3. 部分 HTML/JS/CSS 檔案可直接以瀏覽器開啟。&#10;" />
              <option name="updatedContent" value="# FCU Data Structures And Algorithms&#10;&#10;本專案為逢甲大學資料結構與演算法課程相關的 Java 練習與作業彙整。&#10;&#10;## 課程內容&#10;&#10;- 第1章 資料結構導論（Introduction）&#10;- 第2章 陣列與矩陣（Arrays and Matrices）&#10;- 第3章 鏈結串列（Linked Lists）&#10;- 第4章 堆疊（Stacks）&#10;- 第5章 佇列（Queues）&#10;- 第6章 樹與二元樹（Trees and Binary Trees）&#10;- 第7章 圖形結構（Graphs）&#10;- 第8章 資料排序（Sorting）&#10;- 第9章 資料搜尋（Searching）&#10;&#10;## 專案結構&#10;&#10;- `src/`：所有 Java 原始碼、HTML、CSS、JS 檔案&#10;    - `_20250701/`&#10;        - `GCDLCMCalculator.java`：最大公因數/最小公倍數計算器&#10;        - `ImageViewer.java`：網頁介面簡易圖片瀏覽器&#10;        - `index.html`、`index2.html`、`pomodoro.html`：網頁介面番茄鐘工具&#10;        - `script.js`、`style.css`：網頁腳本與樣式&#10;    - `_20250708/`&#10;        - `MatrixSearchDemo.java`：矩陣搜尋演算法比較&#10;    - `_20250714/`&#10;        - `FactorialComparison.java`：階乘運算效率比較（for迴圈）&#10;        - `FactorialComparison2.java`：階乘運算效率比較（遞迴）&#10;    - `_20250715/`&#10;        - `SparseMatrixGUI.java`：稀疏矩陣操作與顯示&#10;        - `Timetable.java`：課表管理工具&#10;    - `_20250723/`&#10;        - `MusicPlayer.java`：簡易音樂播放器（命令列）&#10;        - `MusicPlayerGUI.java`：簡易音樂播放器（圖形介面）&#10;    - `_20250724/`&#10;        - `InfixConverterGUI.java`：中序轉後序運算式工具&#10;        - `SimplePaint.java`：簡易小畫家1&#10;        - `DrawingApp.java`：簡易小畫家2&#10;    - `_20250728/`&#10;        - `RestaurantSimulation.java` ~ `RestaurantSimulation7.java`：餐廳點餐、排隊、出餐等流程模擬（多版本）&#10;    - `_20250729/`&#10;        - `ArrayBinaryTreeGUI.java`：陣列實作二元樹操作&#10;        - `ProducerGUI.java`：生產者消費者問題模擬&#10;    - `_20250805/`&#10;        - `GraphDemoGUI.java`：圖形結構操作與展示（圖形介面）&#10;        - `GraphGenerator.java`：圖形結構產生器&#10;        - `GraphGUI.java`：圖形結構互動介面&#10;    - `_20250811/`&#10;        - `ArticulationPointComparison.java`：關節點（割點）演算法效能比較&#10;        - `articulation_point_result.csv`：關節點演算法效能比較結果（CSV）&#10;        - `關節點演算法效能比較.pptx`：關節點演算法效能比較ppt&#10;    - `_20250812/`&#10;        - `GraphGeneratorGUI.java`：圖形結構產生器（圖形介面）最短路徑。Dijkstra 演算法、Floyd-Warshall 演算法&#10;    - `_20250818/`&#10;        - `StockDataGenerator.java`：隨機股票資料產生器&#10;        - `StockRankingGUI.java`：股票漲跌幅排行圖形介面&#10;        - `stock_data.csv`：範例股票資料（CSV）&#10;    - `_20250828/`&#10;        - `coursework1/`&#10;            - `ItemTransactionDataGenerator.java`：隨機產生大量物品交易資料（含交易代碼、日期、客戶代碼、物品名稱、價格）&#10;            - `item_transactions.csv`：由程式產生的範例交易資料（CSV 格式）&#10;            - `SearchPerformanceComparison.java`：線性搜尋、二分搜尋、插補搜尋、雜湊搜尋等方法效能比較（含 GUI 與統計分析）&#10;        - `coursework2/`&#10;            - `TradeRecord.java`：單筆交易資料類別&#10;            - `TradeDataManager.java`：股票逐筆交易資料的載入、管理與查詢&#10;            - `TradeDataGUI.java`：股票逐筆交易資料的圖形化查詢介面&#10;            - `2317-Minute-Trade.csv`、`2330-Minute-Trade.csv`、`2382-Minute-Trade.csv`：三檔股票逐筆交易資料（CSV 格式）&#10;            - `prompt.md`：作業說明文件&#10;          &#10;- 主要功能包含：&#10;    - 演算法比較（如矩陣搜尋、階乘運算）&#10;    - 資料結構操作（如二元樹、稀疏矩陣）&#10;    - GUI 應用（如音樂播放器、餐廳模擬、繪圖工具）&#10;    - 其他課堂練習&#10;&#10;## 執行方式&#10;&#10;1. 使用 IntelliJ IDEA 或其他支援 Java 的 IDE 開啟本專案。&#10;2. 進入 `src/` 目錄，選擇欲執行的 Java 檔案，執行主方法（`main`）。&#10;3. 部分 HTML/JS/CSS 檔案可直接以瀏覽器開啟。" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ArrayBinaryTreeGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ArrayBinaryTreeGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class ArrayBinaryTreeGUI extends JPanel {&#10;    String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;};&#10;    JTextField inputField;&#10;    JButton updateButton;&#10;    JButton deleteButton;&#10;    JButton randomButton;&#10;    JLabel infoLabel;&#10;    JRadioButton inorderButton;&#10;    JRadioButton preorderButton;&#10;    JRadioButton postorderButton;&#10;    JButton traverseButton;&#10;    JTextArea resultArea;&#10;&#10;    public ArrayBinaryTreeGUI() {&#10;        setLayout(new BorderLayout());&#10;        JPanel topPanel = new JPanel();&#10;        inputField = new JTextField(15); // 將欄位長度由30改為15&#10;        updateButton = new JButton(&quot;更新陣列&quot;);&#10;        deleteButton = new JButton(&quot;刪除節點&quot;);&#10;        randomButton = new JButton(&quot;隨機產生N個數字&quot;);&#10;        infoLabel = new JLabel(&quot;請輸入以逗號分隔的節點（如：A,B,C,D,E,F,G）&quot;);&#10;        topPanel.add(infoLabel);&#10;        topPanel.add(inputField);&#10;        topPanel.add(updateButton);&#10;        topPanel.add(deleteButton);&#10;        topPanel.add(randomButton);&#10;        add(topPanel, BorderLayout.NORTH);&#10;        updateButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            if (!text.isEmpty()) {&#10;                arr = text.split(&quot;,&quot;);&#10;                for (int i = 0; i &lt; arr.length; i++) {&#10;                    arr[i] = arr[i].trim();&#10;                    if (arr[i].isEmpty()) arr[i] = null;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;        deleteButton.addActionListener(e -&gt; {&#10;            String key = inputField.getText().trim();&#10;            if (key.isEmpty()) return;&#10;            // 找到所有等於 key 的節點&#10;            for (int i = 0; i &lt; arr.length; i++) {&#10;                if (arr[i] != null &amp;&amp; arr[i].equals(key)) {&#10;                    // 判斷是否為樹葉節點&#10;                    int left = 2 * i + 1;&#10;                    int right = 2 * i + 2;&#10;                    boolean isLeaf = (left &gt;= arr.length || arr[left] == null) &amp;&amp; (right &gt;= arr.length || arr[right] == null);&#10;                    if (isLeaf) {&#10;                        arr[i] = null;&#10;                    } else {&#10;                        // 只將該節點及其子樹設為 null，不重整陣列&#10;                        deleteSubtree(i);&#10;                    }&#10;                }&#10;            }&#10;            repaint();&#10;        });&#10;        randomButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            int n;&#10;            try {&#10;                n = Integer.parseInt(text);&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入有效的整數N&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;                return;&#10;            }&#10;            // 產生不重複的隨機數字&#10;            java.util.Set&lt;Integer&gt; set = new java.util.LinkedHashSet&lt;&gt;();&#10;            java.util.Random rand = new java.util.Random();&#10;            int max = Math.max(n * 2, 100);&#10;            while (set.size() &lt; n) {&#10;                set.add(rand.nextInt(max));&#10;            }&#10;            // 將現有陣列擴充或覆蓋&#10;            arr = set.stream().map(String::valueOf).toArray(String[]::new);&#10;            repaint();&#10;        });&#10;        // 拜訪選項與結果顯示&#10;        inorderButton = new JRadioButton(&quot;Inorder&quot;);&#10;        preorderButton = new JRadioButton(&quot;Preorder&quot;);&#10;        postorderButton = new JRadioButton(&quot;Postorder&quot;);&#10;        traverseButton = new JButton(&quot;拜訪&quot;);&#10;        resultArea = new JTextArea(5, 60);&#10;        resultArea.setEditable(false);&#10;        JPanel traversePanel = new JPanel();&#10;        traversePanel.add(new JLabel(&quot;選擇拜訪方式：&quot;));&#10;        traversePanel.add(inorderButton);&#10;        traversePanel.add(preorderButton);&#10;        traversePanel.add(postorderButton);&#10;        traversePanel.add(traverseButton);&#10;        // add(traversePanel, BorderLayout.CENTER); // 移除這行&#10;        // add(new JScrollPane(resultArea), BorderLayout.SOUTH); // 移除這行&#10;        // 新增一個底層面板，垂直排列樹狀圖與拜訪選項&#10;        JPanel bottomPanel = new JPanel();&#10;        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));&#10;        bottomPanel.add(traversePanel);&#10;        bottomPanel.add(new JScrollPane(resultArea));&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;        traverseButton.addActionListener(e -&gt; {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderButton.isSelected()) {&#10;                sb.append(&quot;Inorder: &quot;);&#10;                inorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (preorderButton.isSelected()) {&#10;                sb.append(&quot;Preorder: &quot;);&#10;                preorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (postorderButton.isSelected()) {&#10;                sb.append(&quot;Postorder: &quot;);&#10;                postorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (!inorderButton.isSelected() &amp;&amp; !preorderButton.isSelected() &amp;&amp; !postorderButton.isSelected()) {&#10;                sb.append(&quot;請至少選擇一種拜訪方式！\n&quot;);&#10;            }&#10;            resultArea.setText(sb.toString());&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        drawTree(g, 0, getWidth() / 2 - 15, 80, 120);&#10;    }&#10;&#10;    void drawTree(Graphics g, int index, int x, int y, int xOffset) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        g.drawOval(x, y, 30, 30);&#10;        g.drawString(arr[index], x + 12, y + 20);&#10;        int left = 2 * index + 1;&#10;        if (left &lt; arr.length &amp;&amp; arr[left] != null) {&#10;            g.drawLine(x + 15, y + 30, x - xOffset + 15, y + 80);&#10;            drawTree(g, left, x - xOffset, y + 80, xOffset / 2);&#10;        }&#10;        int right = 2 * index + 2;&#10;        if (right &lt; arr.length &amp;&amp; arr[right] != null) {&#10;            g.drawLine(x + 15, y + 30, x + xOffset + 15, y + 80);&#10;            drawTree(g, right, x + xOffset, y + 80, xOffset / 2);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除子樹&#10;    void deleteSubtree(int index) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        arr[index] = null;&#10;        deleteSubtree(2 * index + 1);&#10;        deleteSubtree(2 * index + 2);&#10;    }&#10;&#10;    // inorder 拜訪&#10;    void inorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        inorder(2 * index + 1, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        inorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // preorder 拜訪&#10;    void preorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        preorder(2 * index + 1, sb);&#10;        preorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // postorder 拜訪&#10;    void postorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        postorder(2 * index + 1, sb);&#10;        postorder(2 * index + 2, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Array Binary Tree Visualization&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(1000, 600);&#10;        frame.add(new ArrayBinaryTreeGUI());&#10;        frame.setVisible(true);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class ArrayBinaryTreeGUI extends JPanel {&#10;    String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;};&#10;    JTextField inputField;&#10;    JButton updateButton;&#10;    JButton deleteButton;&#10;    JButton randomButton;&#10;    JLabel infoLabel;&#10;    JCheckBox inorderBox;&#10;    JCheckBox preorderBox;&#10;    JCheckBox postorderBox;&#10;    JButton traverseButton;&#10;    JTextArea resultArea;&#10;&#10;    public ArrayBinaryTreeGUI() {&#10;        setLayout(new BorderLayout());&#10;        JPanel topPanel = new JPanel();&#10;        inputField = new JTextField(15); // 將欄位長度由30改為15&#10;        updateButton = new JButton(&quot;更新陣列&quot;);&#10;        deleteButton = new JButton(&quot;刪除節點&quot;);&#10;        randomButton = new JButton(&quot;隨機產生N個數字&quot;);&#10;        infoLabel = new JLabel(&quot;請輸入以逗號分隔的節點（如：A,B,C,D,E,F,G）&quot;);&#10;        topPanel.add(infoLabel);&#10;        topPanel.add(inputField);&#10;        topPanel.add(updateButton);&#10;        topPanel.add(deleteButton);&#10;        topPanel.add(randomButton);&#10;        add(topPanel, BorderLayout.NORTH);&#10;        updateButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            if (!text.isEmpty()) {&#10;                arr = text.split(&quot;,&quot;);&#10;                for (int i = 0; i &lt; arr.length; i++) {&#10;                    arr[i] = arr[i].trim();&#10;                    if (arr[i].isEmpty()) arr[i] = null;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;        deleteButton.addActionListener(e -&gt; {&#10;            String key = inputField.getText().trim();&#10;            if (key.isEmpty()) return;&#10;            // 找到所有等於 key 的節點&#10;            for (int i = 0; i &lt; arr.length; i++) {&#10;                if (arr[i] != null &amp;&amp; arr[i].equals(key)) {&#10;                    // 判斷是否為樹葉節點&#10;                    int left = 2 * i + 1;&#10;                    int right = 2 * i + 2;&#10;                    boolean isLeaf = (left &gt;= arr.length || arr[left] == null) &amp;&amp; (right &gt;= arr.length || arr[right] == null);&#10;                    if (isLeaf) {&#10;                        arr[i] = null;&#10;                    } else {&#10;                        // 只將該節點及其子樹設為 null，不重整陣列&#10;                        deleteSubtree(i);&#10;                    }&#10;                }&#10;            }&#10;            repaint();&#10;        });&#10;        randomButton.addActionListener(e -&gt; {&#10;            String text = inputField.getText().trim();&#10;            int n;&#10;            try {&#10;                n = Integer.parseInt(text);&#10;            } catch (NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入有效的整數N&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;                return;&#10;            }&#10;            // 產生不重複的隨機數字&#10;            java.util.Set&lt;Integer&gt; set = new java.util.LinkedHashSet&lt;&gt;();&#10;            java.util.Random rand = new java.util.Random();&#10;            int max = Math.max(n * 2, 100);&#10;            while (set.size() &lt; n) {&#10;                set.add(rand.nextInt(max));&#10;            }&#10;            // 將現有陣列擴充或覆蓋&#10;            arr = set.stream().map(String::valueOf).toArray(String[]::new);&#10;            repaint();&#10;        });&#10;        // 拜訪選項與結果顯示&#10;        inorderBox = new JCheckBox(&quot;Inorder&quot;);&#10;        preorderBox = new JCheckBox(&quot;Preorder&quot;);&#10;        postorderBox = new JCheckBox(&quot;Postorder&quot;);&#10;        traverseButton = new JButton(&quot;拜訪&quot;);&#10;        resultArea = new JTextArea(3, 60);&#10;        resultArea.setEditable(false);&#10;        JPanel traversePanel = new JPanel();&#10;        traversePanel.add(new JLabel(&quot;選擇拜訪方式：&quot;));&#10;        traversePanel.add(inorderBox);&#10;        traversePanel.add(preorderBox);&#10;        traversePanel.add(postorderBox);&#10;        traversePanel.add(traverseButton);&#10;        JPanel bottomPanel = new JPanel();&#10;        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));&#10;        bottomPanel.add(traversePanel);&#10;        bottomPanel.add(new JScrollPane(resultArea));&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;        traverseButton.addActionListener(e -&gt; {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBox.isSelected()) {&#10;                sb.append(&quot;Inorder: &quot;);&#10;                inorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBox.isSelected()) {&#10;                sb.append(&quot;Preorder: &quot;);&#10;                preorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBox.isSelected()) {&#10;                sb.append(&quot;Postorder: &quot;);&#10;                postorder(0, sb);&#10;                sb.append(&quot;\n&quot;);&#10;            }&#10;            if (!inorderBox.isSelected() &amp;&amp; !preorderBox.isSelected() &amp;&amp; !postorderBox.isSelected()) {&#10;                sb.append(&quot;請至少選擇一種拜訪方式！\n&quot;);&#10;            }&#10;            resultArea.setText(sb.toString());&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        drawTree(g, 0, getWidth() / 2 - 15, 80, 120);&#10;    }&#10;&#10;    void drawTree(Graphics g, int index, int x, int y, int xOffset) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        g.drawOval(x, y, 30, 30);&#10;        g.drawString(arr[index], x + 12, y + 20);&#10;        int left = 2 * index + 1;&#10;        if (left &lt; arr.length &amp;&amp; arr[left] != null) {&#10;            g.drawLine(x + 15, y + 30, x - xOffset + 15, y + 80);&#10;            drawTree(g, left, x - xOffset, y + 80, xOffset / 2);&#10;        }&#10;        int right = 2 * index + 2;&#10;        if (right &lt; arr.length &amp;&amp; arr[right] != null) {&#10;            g.drawLine(x + 15, y + 30, x + xOffset + 15, y + 80);&#10;            drawTree(g, right, x + xOffset, y + 80, xOffset / 2);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除子樹&#10;    void deleteSubtree(int index) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        arr[index] = null;&#10;        deleteSubtree(2 * index + 1);&#10;        deleteSubtree(2 * index + 2);&#10;    }&#10;&#10;    // inorder 拜訪&#10;    void inorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        inorder(2 * index + 1, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        inorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // preorder 拜訪&#10;    void preorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;        preorder(2 * index + 1, sb);&#10;        preorder(2 * index + 2, sb);&#10;    }&#10;&#10;    // postorder 拜訪&#10;    void postorder(int index, StringBuilder sb) {&#10;        if (index &gt;= arr.length || arr[index] == null) return;&#10;        postorder(2 * index + 1, sb);&#10;        postorder(2 * index + 2, sb);&#10;        sb.append(arr[index]).append(&quot; &quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Array Binary Tree Visualization&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(1000, 600);&#10;        frame.add(new ArrayBinaryTreeGUI());&#10;        frame.setVisible(true);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ProducerGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ProducerGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Random;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class ProducerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JTextArea logArea;&#10;    private JPanel bufferPanel;&#10;    private ArrayBlockingQueue&lt;String&gt; buffer;&#10;    private ProducerThread producerThread;&#10;    private ConsumerThread consumerThread;&#10;    private FlowAnimationPanel animationPanel;&#10;&#10;    public ProducerGUI() {&#10;        setTitle(&quot;生產者範例&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(900, 500); // 預設較大視窗&#10;        setMinimumSize(new Dimension(900, 500));&#10;        setLayout(new BorderLayout());&#10;&#10;        // 使用 GridBagLayout 讓上方元件不亂掉&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;Buffer 大小: &quot;), gbc);&#10;        gbc.gridx = 1;&#10;        bufferSizeField = new JTextField(&quot;5&quot;, 5);&#10;        topPanel.add(bufferSizeField, gbc);&#10;        gbc.gridx = 2;&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        topPanel.add(startButton, gbc);&#10;        gbc.gridx = 3;&#10;        gbc.weightx = 1;&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        topPanel.add(Box.createHorizontalGlue(), gbc);&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        bufferPanel = new JPanel();&#10;        bufferPanel.setLayout(new FlowLayout(FlowLayout.LEFT));&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot;Buffer 內容 (數據顯示)&quot;));&#10;        add(bufferPanel, BorderLayout.CENTER);&#10;&#10;        logArea = new JTextArea();&#10;        logArea.setEditable(false);&#10;        add(new JScrollPane(logArea), BorderLayout.EAST);&#10;&#10;        animationPanel = new FlowAnimationPanel();&#10;        animationPanel.setPreferredSize(new Dimension(700, 200)); // 放大動畫區域&#10;        add(animationPanel, BorderLayout.SOUTH);&#10;&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                int n;&#10;                try {&#10;                    n = Integer.parseInt(bufferSizeField.getText());&#10;                    if (n &lt;= 0) throw new NumberFormatException();&#10;                } catch (NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(ProducerGUI.this, &quot;請輸入正整數作為 buffer 大小&quot;);&#10;                    return;&#10;                }&#10;                buffer = new ArrayBlockingQueue&lt;&gt;(n);&#10;                logArea.setText(&quot;&quot;);&#10;                if (producerThread != null &amp;&amp; producerThread.isAlive()) {&#10;                    producerThread.interrupt();&#10;                }&#10;                if (consumerThread != null &amp;&amp; consumerThread.isAlive()) {&#10;                    consumerThread.interrupt();&#10;                }&#10;                producerThread = new ProducerThread();&#10;                consumerThread = new ConsumerThread();&#10;                producerThread.start();&#10;                consumerThread.start();&#10;                startButton.setEnabled(false);&#10;                bufferSizeField.setEnabled(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateBufferPanel(String highlightItem, boolean isProduced) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            bufferPanel.removeAll();&#10;            for (String item : buffer) {&#10;                JLabel label = new JLabel(item);&#10;                label.setOpaque(true);&#10;                label.setBorder(BorderFactory.createLineBorder(Color.GRAY));&#10;                if (item.equals(highlightItem)) {&#10;                    if (isProduced) {&#10;                        label.setBackground(Color.YELLOW);&#10;                    } else {&#10;                        label.setBackground(Color.PINK);&#10;                    }&#10;                } else {&#10;                    label.setBackground(Color.WHITE);&#10;                }&#10;                bufferPanel.add(label);&#10;            }&#10;            bufferPanel.revalidate();&#10;            bufferPanel.repaint();&#10;        });&#10;    }&#10;&#10;    private void animateProduce(String item) {&#10;        animationPanel.animateProduce(item);&#10;    }&#10;    private void animateConsume(String item) {&#10;        animationPanel.animateConsume(item);&#10;    }&#10;&#10;    private class ProducerThread extends Thread {&#10;        private final Random rand = new Random();&#10;        private final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                String item = sdf.format(new Date()) + &quot; 編號:&quot; + (rand.nextInt(900) + 100);&#10;                try {&#10;                    buffer.put(item); // 滿時會阻塞&#10;                    SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;生產: &quot; + item + &quot;\n&quot;));&#10;                    updateBufferPanel(item, true);&#10;                    animateProduce(item);&#10;                    Thread.sleep(200);&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                startButton.setEnabled(true);&#10;                bufferSizeField.setEnabled(true);&#10;            });&#10;        }&#10;    }&#10;&#10;    private class ConsumerThread extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                try {&#10;                    String minItem = null;&#10;                    int minNum = Integer.MAX_VALUE;&#10;                    // 找出最小編號物品&#10;                    synchronized (buffer) {&#10;                        for (String item : buffer) {&#10;                            int idx = item.lastIndexOf(&quot;:&quot;);&#10;                            if (idx != -1) {&#10;                                int num = Integer.parseInt(item.substring(idx + 1));&#10;                                if (num &lt; minNum) {&#10;                                    minNum = num;&#10;                                    minItem = item;&#10;                                }&#10;                            }&#10;                        }&#10;                        if (minItem != null) {&#10;                            buffer.remove(minItem);&#10;                        }&#10;                    }&#10;                    if (minItem != null) {&#10;                        String finalMinItem = minItem;&#10;                        SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;消費: &quot; + finalMinItem + &quot;\n&quot;));&#10;                        updateBufferPanel(finalMinItem, false);&#10;                        animateConsume(finalMinItem);&#10;                    }&#10;                    Thread.sleep(300); // 消費速度可調整&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new ProducerGUI().setVisible(true));&#10;    }&#10;&#10;    // 動畫面板類別&#10;    class FlowAnimationPanel extends JPanel {&#10;        private String animatingItem = null;&#10;        private int animX = 0;&#10;        private int animY = 120;&#10;        private int targetX = 0;&#10;        private boolean isProducing = true;&#10;        private Timer timer;&#10;&#10;        public FlowAnimationPanel() {&#10;            setBackground(Color.WHITE);&#10;        }&#10;&#10;        public void animateProduce(String item) {&#10;            animatingItem = item;&#10;            animX = 60; // 生產者區塊右側&#10;            animY = 120;&#10;            targetX = 320; // buffer 區塊左側&#10;            isProducing = true;&#10;            startAnimation();&#10;        }&#10;        public void animateConsume(String item) {&#10;            animatingItem = item;&#10;            animX = 320 + getBufferItemIndex(item) * 60; // buffer區塊內對應物品位置&#10;            animY = 120;&#10;            targetX = 600; // 消費者區塊左側&#10;            isProducing = false;&#10;            startAnimation();&#10;        }&#10;        private void startAnimation() {&#10;            if (timer != null &amp;&amp; timer.isRunning()) timer.stop();&#10;            timer = new Timer(10, e -&gt; {&#10;                if (isProducing) {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                } else {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            timer.start();&#10;        }&#10;        private int getBufferItemIndex(String item) {&#10;            int idx = 0;&#10;            for (String s : buffer) {&#10;                if (s.equals(item)) return idx;&#10;                idx++;&#10;            }&#10;            return 0;&#10;        }&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // 畫三個區塊&#10;            g.setColor(Color.LIGHT_GRAY);&#10;            g.fillRect(20, 100, 80, 80); // 生產者&#10;            g.fillRect(300, 100, 260, 80); // buffer&#10;            g.fillRect(580, 100, 80, 80); // 消費者&#10;            g.setColor(Color.BLACK);&#10;            g.drawRect(20, 100, 80, 80);&#10;            g.drawRect(300, 100, 260, 80);&#10;            g.drawRect(580, 100, 80, 80);&#10;            g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, 16));&#10;            g.drawString(&quot;生產者&quot;, 30, 95);&#10;            g.drawString(&quot;Buffer&quot;, 390, 95);&#10;            g.drawString(&quot;消費者&quot;, 590, 95);&#10;            // 畫箭頭&#10;            g.drawLine(100, 140, 300, 140);&#10;            g.drawLine(560, 140, 580, 140);&#10;            // 畫 buffer 內所有物品（以圓形+編號顯示）&#10;            int i = 0;&#10;            for (String item : buffer) {&#10;                int x = 320 + i * 60;&#10;                int y = 120;&#10;                g.setColor(Color.CYAN);&#10;                g.fillOval(x, y, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(x, y, 40, 40);&#10;                String num = getItemNumber(item);&#10;                g.drawString(num, x + 10, y + 25);&#10;                i++;&#10;            }&#10;            // 畫動畫物品&#10;            if (animatingItem != null) {&#10;                g.setColor(isProducing ? Color.YELLOW : Color.PINK);&#10;                g.fillOval(animX, animY, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(animX, animY, 40, 40);&#10;                String num = getItemNumber(animatingItem);&#10;                g.drawString(num, animX + 10, animY + 25);&#10;            }&#10;        }&#10;        private String getItemNumber(String item) {&#10;            int idx = item.lastIndexOf(&quot;:&quot;);&#10;            if (idx != -1 &amp;&amp; idx + 1 &lt; item.length()) {&#10;                return item.substring(idx + 1).trim();&#10;            }&#10;            return &quot;?&quot;;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Random;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class ProducerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JTextArea logArea;&#10;    private JPanel bufferPanel;&#10;    private ArrayBlockingQueue&lt;String&gt; buffer;&#10;    private ProducerThread producerThread;&#10;    private ConsumerThread consumerThread;&#10;    private FlowAnimationPanel animationPanel;&#10;&#10;    public ProducerGUI() {&#10;        setTitle(&quot;生產者範例&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(900, 500); // 預設較大視窗&#10;        setMinimumSize(new Dimension(900, 500));&#10;        setLayout(new BorderLayout());&#10;&#10;        // 使用 GridBagLayout 讓上方元件不亂掉，並加大間距&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(10, 10, 10, 10);&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        gbc.anchor = GridBagConstraints.WEST;&#10;        topPanel.add(new JLabel(&quot;Buffer 大小: &quot;), gbc);&#10;        gbc.gridx = 1;&#10;        bufferSizeField = new JTextField(&quot;5&quot;, 8);&#10;        topPanel.add(bufferSizeField, gbc);&#10;        gbc.gridx = 2;&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        topPanel.add(startButton, gbc);&#10;        gbc.gridx = 3;&#10;        gbc.weightx = 1;&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        topPanel.add(Box.createHorizontalGlue(), gbc);&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // bufferPanel 放在上方，顯示 buffer 內容&#10;        bufferPanel = new JPanel();&#10;        bufferPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 15, 15));&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot;Buffer 內容 (數據顯示)&quot;));&#10;        bufferPanel.setPreferredSize(new Dimension(900, 70));&#10;        add(bufferPanel, BorderLayout.CENTER);&#10;&#10;        // logArea 放在右側，寬度限制&#10;        logArea = new JTextArea();&#10;        logArea.setEditable(false);&#10;        JScrollPane logScroll = new JScrollPane(logArea);&#10;        logScroll.setPreferredSize(new Dimension(250, 200));&#10;        add(logScroll, BorderLayout.EAST);&#10;&#10;        animationPanel = new FlowAnimationPanel();&#10;        animationPanel.setPreferredSize(new Dimension(700, 200)); // 放大動畫區域&#10;        add(animationPanel, BorderLayout.SOUTH);&#10;&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                int n;&#10;                try {&#10;                    n = Integer.parseInt(bufferSizeField.getText());&#10;                    if (n &lt;= 0) throw new NumberFormatException();&#10;                } catch (NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(ProducerGUI.this, &quot;請輸入正整數作為 buffer 大小&quot;);&#10;                    return;&#10;                }&#10;                buffer = new ArrayBlockingQueue&lt;&gt;(n);&#10;                logArea.setText(&quot;&quot;);&#10;                if (producerThread != null &amp;&amp; producerThread.isAlive()) {&#10;                    producerThread.interrupt();&#10;                }&#10;                if (consumerThread != null &amp;&amp; consumerThread.isAlive()) {&#10;                    consumerThread.interrupt();&#10;                }&#10;                producerThread = new ProducerThread();&#10;                consumerThread = new ConsumerThread();&#10;                producerThread.start();&#10;                consumerThread.start();&#10;                startButton.setEnabled(false);&#10;                bufferSizeField.setEnabled(false);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateBufferPanel(String highlightItem, boolean isProduced) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            bufferPanel.removeAll();&#10;            for (String item : buffer) {&#10;                JLabel label = new JLabel(item);&#10;                label.setOpaque(true);&#10;                label.setBorder(BorderFactory.createLineBorder(Color.GRAY));&#10;                if (item.equals(highlightItem)) {&#10;                    if (isProduced) {&#10;                        label.setBackground(Color.YELLOW);&#10;                    } else {&#10;                        label.setBackground(Color.PINK);&#10;                    }&#10;                } else {&#10;                    label.setBackground(Color.WHITE);&#10;                }&#10;                bufferPanel.add(label);&#10;            }&#10;            bufferPanel.revalidate();&#10;            bufferPanel.repaint();&#10;        });&#10;    }&#10;&#10;    private void animateProduce(String item) {&#10;        animationPanel.animateProduce(item);&#10;    }&#10;    private void animateConsume(String item) {&#10;        animationPanel.animateConsume(item);&#10;    }&#10;&#10;    private class ProducerThread extends Thread {&#10;        private final Random rand = new Random();&#10;        private final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                String item = sdf.format(new Date()) + &quot; 編號:&quot; + (rand.nextInt(900) + 100);&#10;                try {&#10;                    buffer.put(item); // 滿時會阻塞&#10;                    SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;生產: &quot; + item + &quot;\n&quot;));&#10;                    updateBufferPanel(item, true);&#10;                    animateProduce(item);&#10;                    Thread.sleep(200);&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                startButton.setEnabled(true);&#10;                bufferSizeField.setEnabled(true);&#10;            });&#10;        }&#10;    }&#10;&#10;    private class ConsumerThread extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (!isInterrupted()) {&#10;                try {&#10;                    String minItem = null;&#10;                    int minNum = Integer.MAX_VALUE;&#10;                    // 找出最小編號物品&#10;                    synchronized (buffer) {&#10;                        for (String item : buffer) {&#10;                            int idx = item.lastIndexOf(&quot;:&quot;);&#10;                            if (idx != -1) {&#10;                                int num = Integer.parseInt(item.substring(idx + 1));&#10;                                if (num &lt; minNum) {&#10;                                    minNum = num;&#10;                                    minItem = item;&#10;                                }&#10;                            }&#10;                        }&#10;                        if (minItem != null) {&#10;                            buffer.remove(minItem);&#10;                        }&#10;                    }&#10;                    if (minItem != null) {&#10;                        String finalMinItem = minItem;&#10;                        SwingUtilities.invokeLater(() -&gt; logArea.append(&quot;消費: &quot; + finalMinItem + &quot;\n&quot;));&#10;                        updateBufferPanel(finalMinItem, false);&#10;                        animateConsume(finalMinItem);&#10;                    }&#10;                    Thread.sleep(300); // 消費速度可調整&#10;                } catch (InterruptedException e) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new ProducerGUI().setVisible(true));&#10;    }&#10;&#10;    // 動畫面板類別&#10;    class FlowAnimationPanel extends JPanel {&#10;        private String animatingItem = null;&#10;        private int animX = 0;&#10;        private int animY = 120;&#10;        private int targetX = 0;&#10;        private boolean isProducing = true;&#10;        private Timer timer;&#10;&#10;        public FlowAnimationPanel() {&#10;            setBackground(Color.WHITE);&#10;        }&#10;&#10;        public void animateProduce(String item) {&#10;            animatingItem = item;&#10;            animX = 60; // 生產者區塊右側&#10;            animY = 120;&#10;            targetX = 320; // buffer 區塊左側&#10;            isProducing = true;&#10;            startAnimation();&#10;        }&#10;        public void animateConsume(String item) {&#10;            animatingItem = item;&#10;            animX = 320 + getBufferItemIndex(item) * 60; // buffer區塊內對應物品位置&#10;            animY = 120;&#10;            targetX = 600; // 消費者區塊左側&#10;            isProducing = false;&#10;            startAnimation();&#10;        }&#10;        private void startAnimation() {&#10;            if (timer != null &amp;&amp; timer.isRunning()) timer.stop();&#10;            timer = new Timer(10, e -&gt; {&#10;                if (isProducing) {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                } else {&#10;                    if (animX &lt; targetX) {&#10;                        animX += 8;&#10;                        repaint();&#10;                    } else {&#10;                        ((Timer)e.getSource()).stop();&#10;                        animatingItem = null;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            timer.start();&#10;        }&#10;        private int getBufferItemIndex(String item) {&#10;            int idx = 0;&#10;            for (String s : buffer) {&#10;                if (s.equals(item)) return idx;&#10;                idx++;&#10;            }&#10;            return 0;&#10;        }&#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // 畫三個區塊&#10;            g.setColor(Color.LIGHT_GRAY);&#10;            g.fillRect(20, 100, 80, 80); // 生產者&#10;            g.fillRect(300, 100, 260, 80); // buffer&#10;            g.fillRect(580, 100, 80, 80); // 消費者&#10;            g.setColor(Color.BLACK);&#10;            g.drawRect(20, 100, 80, 80);&#10;            g.drawRect(300, 100, 260, 80);&#10;            g.drawRect(580, 100, 80, 80);&#10;            g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, 16));&#10;            g.drawString(&quot;生產者&quot;, 30, 95);&#10;            g.drawString(&quot;Buffer&quot;, 390, 95);&#10;            g.drawString(&quot;消費者&quot;, 590, 95);&#10;            // 畫箭頭&#10;            g.drawLine(100, 140, 300, 140);&#10;            g.drawLine(560, 140, 580, 140);&#10;            // 畫 buffer 內所有物品（以圓形+編號顯示）&#10;            int i = 0;&#10;            for (String item : buffer) {&#10;                int x = 320 + i * 60;&#10;                int y = 120;&#10;                g.setColor(Color.CYAN);&#10;                g.fillOval(x, y, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(x, y, 40, 40);&#10;                String num = getItemNumber(item);&#10;                g.drawString(num, x + 10, y + 25);&#10;                i++;&#10;            }&#10;            // 畫動畫物品&#10;            if (animatingItem != null) {&#10;                g.setColor(isProducing ? Color.YELLOW : Color.PINK);&#10;                g.fillOval(animX, animY, 40, 40);&#10;                g.setColor(Color.BLACK);&#10;                g.drawOval(animX, animY, 40, 40);&#10;                String num = getItemNumber(animatingItem);&#10;                g.drawString(num, animX + 10, animY + 25);&#10;            }&#10;        }&#10;        private String getItemNumber(String item) {&#10;            int idx = item.lastIndexOf(&quot;:&quot;);&#10;            if (idx != -1 &amp;&amp; idx + 1 &lt; item.length()) {&#10;                return item.substring(idx + 1).trim();&#10;            }&#10;            return &quot;?&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/_20250828/prompt.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/_20250828/prompt.md" />
              <option name="originalContent" value="# prompt.md&#10;&#10;## 專案需求與設計過程紀錄&#10;&#10;### 1. 需求描述&#10;&#10;設計一個股票交易資料查詢系統，具備以下功能：&#10;- 載入CSV檔案，顯示股票逐筆交易資料。&#10;- 支援依日期、時間、區間查詢。&#10;- 可選擇顯示欄位（日期、時間、開盤價、收盤價、最高價、最低價、成交量）。&#10;- 查詢結果可匯出為CSV檔案。&#10;&#10;### 2. 主要程式檔案&#10;- TradeDataGUI.java：Swing圖形介面，負責用戶互動、查詢與顯示。&#10;- TradeDataManager.java：資料管理與查詢邏輯。&#10;- TradeRecord.java：單筆交易資料物件。&#10;&#10;### 3. 開發過程與重點&#10;- 以JFrame為主視窗，左側為查詢條件，右側為查詢結果表格。&#10;- 支援載入多種格式的日期（自動補0），查詢時自動格式化。&#10;- 查詢可依單一分鐘、單日、區間（起訖日或天數）進行。&#10;- 查詢結果可選擇欄位顯示，並可匯出。&#10;- 例外處理與提示訊息完整。&#10;&#10;### 4. 典型Prompt範例&#10;&#10;#### 4.1 需求描述&#10;```&#10;請設計一個Java Swing GUI程式，可以載入股票逐筆交易CSV檔，支援依日期、時間、區間查詢，並可選擇顯示欄位與匯出查詢結果。&#10;```&#10;&#10;#### 4.2 介面設計&#10;```&#10;請在GUI左側加入查詢條件（日期、時間、區間、欄位勾選），右側顯示查詢結果表格，下方有查詢與匯出按鈕。&#10;```&#10;&#10;#### 4.3 查詢功能&#10;```&#10;請實作依日期、時間、區間查詢功能，並能選擇顯示欄位。&#10;```&#10;&#10;#### 4.4 匯出功能&#10;```&#10;請將查詢結果匯出為CSV檔案，欄位順序與勾選一致。&#10;```&#10;&#10;#### 4.5 例外處理&#10;```&#10;請在載入、查詢、匯出時加入例外處理與提示訊息。&#10;```&#10;&#10;---&#10;&#10;本檔案記錄本專案的需求、設計重點與典型prompt，供未來維護與擴充參考。&#10;" />
              <option name="updatedContent" value="# prompt.md&#10;&#10;## 專案完整自動生成指令（給AI Copilot/Compiler）&#10;&#10;### 目標&#10;&#10;請根據本檔案內容，**自動產生並執行**下列三個Java檔案，並確保其功能如下：&#10;- TradeDataGUI.java：Swing圖形介面，負責用戶互動、查詢與顯示。&#10;- TradeDataManager.java：資料管理與查詢邏輯。&#10;- TradeRecord.java：單筆交易資料物件。&#10;&#10;### 需求說明&#10;&#10;設計一個「股票交易資料查詢系統」，具備以下功能：&#10;1. 載入CSV檔案，顯示股票逐筆交易資料。&#10;2. 支援依日期、時間、區間查詢。&#10;3. 可選擇顯示欄位（日期、時間、開盤價、收盤價、最高價、最低價、成交量）。&#10;4. 查詢結果可匯出為CSV檔案。&#10;&#10;### 介面與操作流程&#10;&#10;- 啟動程式後，出現主視窗：&#10;    - 上方有「載入CSV檔案」按鈕。&#10;    - 左側為查詢條件（日期、時間、區間、欄位勾選）。&#10;    - 右側為查詢結果表格。&#10;    - 下方有「查詢」與「匯出CSV」按鈕。&#10;- 查詢條件支援：&#10;    - 指定日期(yyyy/MM/dd)與時間(HH:mm)查詢單一分鐘。&#10;    - 僅輸入日期查詢單日。&#10;    - 區間查詢（起訖日或起始日+天數）。&#10;    - 勾選要顯示的欄位。&#10;- 查詢結果可直接匯出為CSV，欄位順序與勾選一致。&#10;- 所有操作皆有例外處理與提示訊息。&#10;&#10;### 典型Prompt範例（請依下列語意自動產生程式碼）&#10;&#10;#### 1. 需求描述&#10;```&#10;請設計一個Java Swing GUI程式，可以載入股票逐筆交易CSV檔，支援依日期、時間、區間查詢，並可選擇顯示欄位與匯出查詢結果。&#10;```&#10;&#10;#### 2. 介面設計&#10;```&#10;請在GUI左側加入查詢條件（日期、時間、區間、欄位勾選），右側顯示查詢結果表格，下方有查詢與匯出按鈕。&#10;```&#10;&#10;#### 3. 查詢功能&#10;```&#10;請實作依日期、時間、區間查詢功能，並能選擇顯示欄位。&#10;```&#10;&#10;#### 4. 匯出功能&#10;```&#10;請將查詢結果匯出為CSV檔案，欄位順序與勾選一致。&#10;```&#10;&#10;#### 5. 例外處理&#10;```&#10;請在載入、查詢、匯出時加入例外處理與提示訊息。&#10;```&#10;&#10;### 產出規範&#10;&#10;- 產生的三個Java檔案需互相配合，能直接編譯與執行。&#10;- 不需額外第三方函式庫。&#10;- 程式碼需包含註解，便於理解。&#10;- 介面與功能需符合上述需求。&#10;- 若有資料範例，請以「日期,時間,開盤價,收盤價,最高價,最低價,成交量」為欄位順序。&#10;&#10;---&#10;&#10;&gt; **說明：**&#10;&gt; 只要將本檔案交給AI Copilot或Compiler，照上述指令即可自動產生TradeDataGUI.java、TradeDataManager.java、TradeRecord.java三個檔案，並具備完整查詢、匯出、例外處理等功能。無須再補充其他需求。" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>